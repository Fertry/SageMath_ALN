{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-11d80b8e-cb5b-4644-abb4-669f6978e9fb.json","kernel":"sagemath","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language":"python","language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.7"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1619849956481,"exec_count":1,"id":"539893","input":"#auto\ndef tril(A,k):\n    return matrix(A.base_ring(), A.nrows(), A.ncols(), lambda i,j: A[i,j] if j <= i+k else 0)\n    \ndef triu(A):\n    L = copy(A).transpose()\n    return(tril(L, 0).transpose())\n    \ndef factorizacion_QR(A):\n    q = []  # Lista de los vectores qi (columnas de Q)\n    for ak in A.columns():\n        yk = ak - sum( qi.dot_product(ak) * qi for qi in q )# dot_product es el p.escalar usual\n        qk = yk/yk.norm(2)\n        q.append(qk)\n    Q = matrix(q).transpose()\n    R = triu(Q.transpose()*A) # Q.transpose()*A ya es triangular superior, excepto por los redondeos\n                              # Aplicar triu elimina los coeficientes muy pequeños debajo de la diag. \n    return Q, R","kernel":"sagemath","pos":2,"start":1619849956451,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957098,"exec_count":2,"id":"dfd57b","input":"def forma_escalonada(M, canon = False, ver_transfo = False, algoritmo = 'sin pivotear'):\n    A  = copy(M)\n    m  = A.nrows() # número de filas\n    n  = A.ncols() # número de columnas\n    mindim = min(m, n)\n    lista_transfos = []                         # Lista que recordará las operaciones realizadas.\n    F  = copy(identity_matrix(base_ring(A), m)) \n    s  = 0\n    for k in range(mindim):\n        (r, s) = busca_pivote[algoritmo](A,  k, s)\n        if (r < m) and (s < n):   # Si hemos encontrado un pivote...\n            if (r != k):          #    Si el pivote no está en la primera fila considerada...  \n                A.swap_rows(k, r) #    ... lo colocamos allí (fila k)\n                F.swap_rows(k, r)\n                lista_transfos.append( ('swap',(k+1,r+1)) )\n            piv = A[k, s]             # Valor del pivote. Su posicion es ahora: fila k, col s.\n            ### reduccion debajo del pivote ### \n            for t in range(k + 1, m): # reducimos los coeficientes DEBAJO del pivote.\n                multip = A[t, s]*piv^-1 \n                if multip != 0:\n                    A[t, s] = 0\n                    F[t] = F[t] - multip*F[k]\n                    lista_transfos.append( ('combination', (t+1, k+1, -multip)))\n                    for v in range(s + 1, n):\n                        A[t, v] = A[t, v] - multip*A[k, v]\n            ### reduccion encima del pivote ###            \n            if canon:    \n                for t in range(k):   \n                    multip = A[t, s]*piv^(-1)\n                    if multip != 0:\n                        A[t, s] = 0\n                        F[t] = F[t] - multip*F[k]\n                        lista_transfos.append( ('combination',(t+1, k+1, -multip)))\n                        for v in range(s + 1, n):\n                            A[t, v] = A[t, v] - multip*A[k, v]\n                F[k] = F[k]*piv^(-1)  # reducimos también el pivote a 1.\n                A[k] = A[k]*piv^(-1)\n                lista_transfos.append( ('rescale', (k+1, piv^(-1))) )\n        s = s+1        \n    print\n    ## Presentación de los resultados\n    if ver_transfo: \n        show_operations(M, lista_transfos)\n        if canon: print('Forma escalonada canónica:')\n        else: print('Forma escalonada simple:')\n        show(A)\n    return(F, A)    \n        \nbusca_pivote={}\n\ndef busca_pivote_sin_pivotear(A, k, s):\n    '''Se busca como pivote el primer coeficiente no-nulo, \n    en las filas k y siguientes, columna s y siguientes.'''\n    r = k\n    (m, n) = A.dimensions()\n    while (r < m) and (s < n) and (A[r, s] == 0):\n       r = r + 1                    # ... en primer lugar en la misma columna s.\n       if r == m: (r, s) = (k, s+1) # pasamos a la columna siguiente\n    return(r,s)\n    \nbusca_pivote['sin pivotear'] = busca_pivote_sin_pivotear\n\ndef show_operations(M, lista_transfos):\n    'Presentacion de las operaciones elementales.'\n    print('Matriz original:')\n    show(M)\n    print\n    print('Transformaciones elementales realizadas:')\n    for (tipo, parametros) in lista_transfos:\n        if tipo == 'swap':\n            (indice1, indice2) = parametros\n            pretty_print(html('$F_{%s,%s}$'%(latex(indice1), latex(indice2))))\n            print\n        elif tipo == 'combination':\n            (indice1, indice2, factor) = parametros\n            pretty_print(html('$F_{%s,%s}(%s)$'%(latex(indice1),latex(indice2), latex(factor))))  \n            print\n        elif tipo == 'rescale':\n            (indice, factor) = parametros\n            pretty_print(html('$F_{%s}(%s)$'%(latex(indice), latex(factor))))  \n            print\n    return None\n    \ndef sustitucion_regresiva(U):\n    m = U.ncols()\n    n = U.nrows()\n    # Se separa la ultima columna: U = ( M | x )\n    M = U.submatrix(ncols=m-1) # Las m-1 primeras columnas (se quita la ultima)\n    x = U.column(-1)           # La ultima columna.\n    for k in range(n - 1, -1, -1):\n        x[k] = (x[k] - sum(M[k, j]*x[j] for j in range(k + 1, n)))/M[k, k]\n    return x","kernel":"sagemath","pos":3,"start":1619849957095,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957153,"exec_count":3,"id":"d78f82","input":"A = matrix(RDF, [[1, 2, -1], [3, 4, 0], [-1, 0, 1], [1, 1, 1]])\nshow(A)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n1.0 & 2.0 & -1.0 \\\\\n3.0 & 4.0 & 0.0 \\\\\n-1.0 & 0.0 & 1.0 \\\\\n1.0 & 1.0 & 1.0\n\\end{array}\\right)</script></html>","text/plain":"[ 1.0  2.0 -1.0]\n[ 3.0  4.0  0.0]\n[-1.0  0.0  1.0]\n[ 1.0  1.0  1.0]"}}},"pos":5,"start":1619849957148,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957175,"exec_count":4,"id":"5f1892","input":"A.rank()","kernel":"sagemath","output":{"0":{"data":{"text/plain":"3"},"exec_count":4}},"pos":7,"start":1619849957161,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957452,"exec_count":5,"id":"bd58d8","input":"Q, R = factorizacion_QR(A)\nshow(Q)\nshow(R)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.2886751345948129 & 0.49999999999999967 & -0.5883484054145521 \\\\\n0.8660254037844388 & 0.16666666666666546 & 0.13074409009212282 \\\\\n-0.2886751345948129 & 0.8333333333333336 & 0.45760431532242923 \\\\\n0.2886751345948129 & -0.16666666666666696 & 0.6537204504606136\n\\end{array}\\right)</script></html>","text/plain":"[  0.2886751345948129  0.49999999999999967  -0.5883484054145521]\n[  0.8660254037844388  0.16666666666666546  0.13074409009212282]\n[ -0.2886751345948129   0.8333333333333336  0.45760431532242923]\n[  0.2886751345948129 -0.16666666666666696   0.6537204504606136]"}},"1":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n3.4641016151377557 & 4.3301270189221945 & -0.2886751345948129 \\\\\n0.0 & 1.4999999999999942 & 0.16666666666666696 \\\\\n0.0 & 0.0 & 1.699673171197595\n\\end{array}\\right)</script></html>","text/plain":"[ 3.4641016151377557  4.3301270189221945 -0.2886751345948129]\n[                0.0  1.4999999999999942 0.16666666666666696]\n[                0.0                 0.0   1.699673171197595]"}}},"pos":8,"start":1619849957184,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957476,"exec_count":6,"id":"53967c","input":"Q*R == A  ## trabajando con valores decimales, es difícil obtener una identidad exacta","kernel":"sagemath","output":{"0":{"data":{"text/plain":"False"},"exec_count":6}},"pos":10,"start":1619849957460,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957505,"exec_count":7,"id":"35c05b","input":"show(Q*R - A)  ## vemos la matriz diferencia entre ambos lados de la igualdad anterior","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n4.440892098500626 \\times 10^{-16} & -2.886579864025407 \\times 10^{-15} & 0.0 \\\\\n1.7763568394002505 \\times 10^{-15} & -8.881784197001252 \\times 10^{-16} & 1.3605273113931605 \\times 10^{-17} \\\\\n-4.440892098500626 \\times 10^{-16} & -4.866477591273605 \\times 10^{-15} & 0.0 \\\\\n4.440892098500626 \\times 10^{-16} & 8.881784197001252 \\times 10^{-16} & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[ 4.440892098500626e-16 -2.886579864025407e-15                    0.0]\n[1.7763568394002505e-15 -8.881784197001252e-16 1.3605273113931605e-17]\n[-4.440892098500626e-16 -4.866477591273605e-15                    0.0]\n[ 4.440892098500626e-16  8.881784197001252e-16                    0.0]"}}},"pos":11,"start":1619849957483,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957563,"exec_count":8,"id":"8aaae0","input":"show((Q*R - A).zero_at(10^(-14)) ) # comprobamos que, salvo pequeños errores, QR = A   pues   QR-A = O","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]"}}},"pos":13,"start":1619849957514,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957585,"exec_count":9,"id":"3e2d87","input":"show((Q*R - A).zero_at(10^-16)) # si bajamos el nivel de tolerancia, siguen visibles algunos errores","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n4.440892098500626 \\times 10^{-16} & -2.886579864025407 \\times 10^{-15} & 0.0 \\\\\n1.7763568394002505 \\times 10^{-15} & -8.881784197001252 \\times 10^{-16} & 0.0 \\\\\n-4.440892098500626 \\times 10^{-16} & -4.866477591273605 \\times 10^{-15} & 0.0 \\\\\n4.440892098500626 \\times 10^{-16} & 8.881784197001252 \\times 10^{-16} & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[ 4.440892098500626e-16 -2.886579864025407e-15                    0.0]\n[1.7763568394002505e-15 -8.881784197001252e-16                    0.0]\n[-4.440892098500626e-16 -4.866477591273605e-15                    0.0]\n[ 4.440892098500626e-16  8.881784197001252e-16                    0.0]"}}},"pos":14,"start":1619849957575,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957624,"exec_count":10,"id":"3f9d92","input":"(Q*R - A).norm(2)  ## norma euclídea de la diferencia","kernel":"sagemath","output":{"0":{"data":{"text/plain":"5.796185880507392e-15"},"exec_count":10}},"pos":16,"start":1619849957591,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957653,"exec_count":11,"id":"e17cad","input":"show(Q)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.2886751345948129 & 0.49999999999999967 & -0.5883484054145521 \\\\\n0.8660254037844388 & 0.16666666666666546 & 0.13074409009212282 \\\\\n-0.2886751345948129 & 0.8333333333333336 & 0.45760431532242923 \\\\\n0.2886751345948129 & -0.16666666666666696 & 0.6537204504606136\n\\end{array}\\right)</script></html>","text/plain":"[  0.2886751345948129  0.49999999999999967  -0.5883484054145521]\n[  0.8660254037844388  0.16666666666666546  0.13074409009212282]\n[ -0.2886751345948129   0.8333333333333336  0.45760431532242923]\n[  0.2886751345948129 -0.16666666666666696   0.6537204504606136]"}}},"pos":18,"start":1619849957629,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957683,"exec_count":12,"id":"8becc7","input":"show(Q.transpose()*Q - 1)  # calculamos el valor numérico de   Q^t*Q-I; la matriz identidad aquí se expresa con 1","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n4.440892098500626 \\times 10^{-16} & -1.2697029012172143 \\times 10^{-15} & 1.9017303711800425 \\times 10^{-16} \\\\\n-1.2697029012172143 \\times 10^{-15} & -1.1102230246251565 \\times 10^{-16} & -1.7966234439743946 \\times 10^{-16} \\\\\n1.9017303711800425 \\times 10^{-16} & -1.7966234439743946 \\times 10^{-16} & 2.220446049250313 \\times 10^{-16}\n\\end{array}\\right)</script></html>","text/plain":"[  4.440892098500626e-16 -1.2697029012172143e-15  1.9017303711800425e-16]\n[-1.2697029012172143e-15 -1.1102230246251565e-16 -1.7966234439743946e-16]\n[ 1.9017303711800425e-16 -1.7966234439743946e-16   2.220446049250313e-16]"}}},"pos":19,"start":1619849957659,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957702,"exec_count":13,"id":"9f9ca8","input":"(Q.transpose()*Q - 1).norm(2)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"1.5186812782122959e-15"},"exec_count":13}},"pos":20,"start":1619849957690,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957756,"exec_count":14,"id":"340782","input":"show((Q.transpose()*Q - 1).zero_at(10^-14))","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]"}}},"pos":21,"start":1619849957710,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957780,"exec_count":15,"id":"f1d392","input":"show(Q*Q.transpose())   ### no se obtiene la matriz unidad de orden 4","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrrr}\n0.6794871794871792 & 0.2564102564102558 & 0.064102564102564 & -0.3846153846153848 \\\\\n0.2564102564102558 & 0.7948717948717948 & -0.051282051282052266 & 0.307692307692308 \\\\\n0.064102564102564 & -0.051282051282052266 & 0.9871794871794874 & 0.07692307692307654 \\\\\n-0.3846153846153848 & 0.307692307692308 & 0.07692307692307654 & 0.5384615384615388\n\\end{array}\\right)</script></html>","text/plain":"[   0.6794871794871792    0.2564102564102558     0.064102564102564   -0.3846153846153848]\n[   0.2564102564102558    0.7948717948717948 -0.051282051282052266     0.307692307692308]\n[    0.064102564102564 -0.051282051282052266    0.9871794871794874   0.07692307692307654]\n[  -0.3846153846153848     0.307692307692308   0.07692307692307654    0.5384615384615388]"}}},"pos":23,"start":1619849957766,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957800,"exec_count":16,"id":"b6057e","input":"def matrizHilbert(n):\n    r\"\"\"\n    Calcula la matriz de Hilbert de orden n.\n    Una tal función ya está proporcionada por SAGE8 (matrix.hilbert) \n    pero no por las versiones anteriores.\n    \"\"\"\n    return matrix(QQ, n, lambda i, j: 1/(i+j+1) )\n    # 1/(i+j+1) en vez de 1/(i+j-1) ya que i,j empiezan a 0","kernel":"sagemath","pos":25,"start":1619849957793,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849957978,"exec_count":17,"id":"4bf1e4","input":"A = matrizHilbert(15).n()","kernel":"sagemath","pos":26,"start":1619849957861,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958000,"exec_count":18,"id":"97ba50","input":"Q, R = factorizacion_QR(A)","kernel":"sagemath","pos":27,"start":1619849957995,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958199,"exec_count":19,"id":"4376ba","input":"(Q*R - A).norm(2)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"0.00031997644119073474"},"exec_count":19}},"pos":28,"start":1619849958046,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958250,"exec_count":20,"id":"45b5a8","input":"(Q.transpose()*Q - 1).norm(2)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"7.996252222451788"},"exec_count":20}},"pos":29,"start":1619849958206,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958293,"exec_count":21,"id":"6a6cc2","input":"def numero_condicion(A, p = 2):\n    try:\n        B = A.inverse() \n        cond = 0\n        if p == 2: \n            cond = A.norm(2)*B.norm(2) \n        if p == 1: \n            cond = A.norm(1)*B.norm(1) \n        if p == Infinity: \n            cond = A.norm(Infinity)*B.norm(Infinity) \n    except ZeroDivisionError:\n        print(' Error: la matriz ha de ser cuadrada y no singular.')\n    if cond == 0:\n        print(' Error: sólo se contemplan las normas p=1, p=2, p=Infinity.')\n    return cond","kernel":"sagemath","pos":31,"start":1619849958260,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958351,"exec_count":22,"id":"dda755","input":"numero_condicion(A)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"4.197819332639827e+17"},"exec_count":22}},"pos":32,"start":1619849958299,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958415,"exec_count":23,"id":"d6b4b5","input":"def descompPLU(M):\n    r'Descomposicion PlU de A. Se tiene PA=LU.'\n    A = copy(M)\n    m = A.nrows(); n = A.ncols()\n    piv = list(range(n))\n    for k in range(m):\n        (vmax, q) = max(  (abs(A[s, k]), s) for s in range(k, m) )\n        if q != k:\n            piv[k], piv[q] = piv[q], piv[k]\n            A.swap_rows(q, k)\n        if A[k, k] != 0:\n            for t in range(k + 1, m):\n                A[t, k]    = A[t, k]/A[k, k]\n                A[t, k+1:] = A[t, k+1:] - A[t, k]*A[k, k+1:]\n    L = identity_matrix(base_ring(A), m) + tril(A, -1)\n    U = triu(A)\n    P = identity_matrix(base_ring(A), m).matrix_from_rows(piv)\n    return P, L, U\n            \ndef modifica_lado_derecho(L, b):\n    r'''\n    \n    '''\n    g = copy(b)\n    n = len(b)\n    for k in range(n - 1):\n        for j in range(k + 1, n):\n            g[j] = g[j] - g[k]*L[j, k]\n    return g    \n\n\n            \ndef sustitucion_regresiva2(U, g):\n    r'''\n    Resuelve Ux=g, con U triangular superior, por sustitucion regresiva.\n    '''\n    n = U.ncols()\n    x = copy(g)\n    for k in range(n - 1, -1, -1):\n        x[k] = (g[k] - sum(U[k, j]*x[j] for j in range(k + 1, n)))/U[k, k]\n    return x","kernel":"sagemath","pos":35,"start":1619849958399,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958472,"exec_count":24,"id":"895069","input":"A = random_matrix(RDF, 20)  # generamos una matriz aleatoria de orden 20 \n                            # con coeficientes en el intervalo (-1,1)","kernel":"sagemath","pos":36,"start":1619849958424,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958502,"exec_count":25,"id":"e5a005","input":"Q, R = factorizacion_QR(A)","kernel":"sagemath","pos":37,"start":1619849958480,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958559,"exec_count":26,"id":"edc74a","input":"cond_A, cond_R = numero_condicion(A), numero_condicion(R)\nprint(cond_A)\nprint(cond_R)","kernel":"sagemath","output":{"0":{"name":"stdout","text":"722.7162989002824\n722.7162988961012\n"}},"pos":38,"start":1619849958513,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958590,"exec_count":27,"id":"5fdbc8","input":"numero_condicion(Q)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"1.000000000000159"},"exec_count":27}},"pos":39,"start":1619849958566,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958684,"exec_count":28,"id":"bfc989","input":"P, L, U = descompPLU(A)  # hallamos la descomposición PLU de la matriz A","kernel":"sagemath","pos":40,"start":1619849958604,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958721,"exec_count":29,"id":"3ad45d","input":"cond_A, cond_U, cond_L = numero_condicion(A), numero_condicion(U), numero_condicion(L)\nprint(cond_A)\nprint(cond_U)\nprint(cond_L)","kernel":"sagemath","output":{"0":{"name":"stdout","text":"722.7162989002824\n432.7981065421073\n23.442602896272113\n"}},"pos":41,"start":1619849958699,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958763,"exec_count":30,"id":"dce5bc","input":"cond_U * cond_L","kernel":"sagemath","output":{"0":{"data":{"text/plain":"10145.914145925091"},"exec_count":30}},"pos":42,"start":1619849958730,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958961,"exec_count":31,"id":"a2cc8c","input":"cond_U * cond_L / cond_A  ### calculamos en qué proporción puede ser peor un resultado que otro","kernel":"sagemath","output":{"0":{"data":{"text/plain":"14.03858493486804"},"exec_count":31}},"pos":43,"start":1619849958845,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849958981,"exec_count":32,"id":"172c6c","input":"A = matrizHilbert(20)","kernel":"sagemath","pos":45,"start":1619849958973,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959033,"exec_count":33,"id":"a0f0b9","input":"x0 = vector(QQ, [1]*20)  # esta es la solución exacta x0=(1,1,....,1)\nb  = A*x0\n\nA*x0 == b","kernel":"sagemath","output":{"0":{"data":{"text/plain":"True"},"exec_count":33}},"pos":47,"start":1619849958994,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959064,"exec_count":34,"id":"64c991","input":"A = A.change_ring(RDF)\nb = vector(RDF, list(b))","kernel":"sagemath","pos":49,"start":1619849959047,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959096,"exec_count":35,"id":"0c627a","input":"A*x0 == b   ### al pasar a valores decimales, x0 ha dejado de ser la solución exacta","kernel":"sagemath","output":{"0":{"data":{"text/plain":"False"},"exec_count":35}},"pos":50,"start":1619849959071,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959134,"exec_count":36,"id":"d28f8a","input":"(A*x0 - b).norm()   ### el error residual es muy pequeño","kernel":"sagemath","output":{"0":{"data":{"text/plain":"6.568167990716596e-16"},"exec_count":36}},"pos":51,"start":1619849959103,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959186,"exec_count":37,"id":"546f5e","input":"M = block_matrix([[A, b.column()]])        ### matriz ampliada del sistema\nF, U = forma_escalonada(M)                 ### escalonamiento de la matriz\nxd = sustitucion_regresiva(U)              ### solución por sustitución regresiva\nxd","kernel":"sagemath","output":{"0":{"name":"stdout","text":"\n"},"1":{"data":{"text/plain":"(1.000000124226477, 0.9999796755284203, 1.0008244799317345, 0.9855194857487556, 1.1365871296462322, 0.2313994092835615, 3.7153571964135423, -5.115792992417402, 9.694637349911602, -7.030204680429338, 8.615582812887048, -12.276898850221569, 20.760586096148497, -13.261390805736797, -2.1988590931521714, 19.541494241608962, -20.704358420716225, 15.62232969107717, -4.703545047394849, 1.986752247745273)"},"exec_count":37}},"pos":53,"start":1619849959142,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959269,"exec_count":38,"id":"1ac88c","input":"P, L, U = descompPLU(A)\nbp = P*b                                       # obtenemos el vector P*b\ng    = modifica_lado_derecho(L,bp)             # g es la solución del sistema auxiliar Lg=Pb\nxplu = sustitucion_regresiva2(U, g)            # xplu es la solución final del sistema Ux=g\nxplu","kernel":"sagemath","output":{"0":{"data":{"text/plain":"(1.0000000086426724, 0.9999986657161956, 1.000051870354066, 0.9991154891259608, 1.0081538624512598, 0.9554259795063353, 1.1480447591128848, 0.7179174753630226, 1.2219909210581241, 1.1349811979685378, 0.9046499198959809, -0.1506153244366207, 3.2583719348362883, 0.5724925380487212, -2.78859172959099, 7.021744897670579, -3.3827258983473394, 2.625929343329312, 0.7555313550930265, 0.9975327354788517)"},"exec_count":38}},"pos":55,"start":1619849959199,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959305,"exec_count":39,"id":"86544e","input":"Q, R = factorizacion_QR(A)\nbq = Q.transpose()*b                   ### obtenemos el vector Q^t*b\nxqr = sustitucion_regresiva2(R,bq)     ### xqr es la solución del sistema Ax=b \n                                       ### mediante descomposicion QR\nxqr","kernel":"sagemath","output":{"0":{"data":{"text/plain":"(0.8824552251796146, 5.4034958804679265, -38.79421795777929, 143.29377611050722, -227.13910274431325, 153.00537229678469, -22.65428412455036, -0.21363477456984795, -0.035287034344950945, -0.010296416782555851, -0.0040622140079408205, -0.0019378353011709924, -0.0010531956663128086, -0.0006290818715356001, -0.00040355242049142304, -0.00027364615643954974, -0.00019394891499679046, -0.00014251104519901131, -0.00010787171274814215, 6.342608654745293)"},"exec_count":39}},"pos":57,"start":1619849959275,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959348,"exec_count":40,"id":"00d31f","input":"print((xd - x0).norm())     ## método directo de escalonamiento\nprint((xplu - x0).norm())   ## método descomposicion PLU\nprint((xqr - x0).norm())    ## método descomposicion QR","kernel":"sagemath","output":{"0":{"name":"stdout","text":"45.67300403263424\n8.905818207115125\n312.4167700130572\n"}},"pos":59,"start":1619849959312,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959367,"exec_count":41,"id":"5e36be","input":"print((A*x0 - b).norm())     ## error residual de la solución exacta x0\nprint((A*xd - b).norm())     ## error residual de la solución mediante escalonamiento\nprint((A*xplu - b).norm())   ## error residual mediante PLU\nprint((A*xqr - b).norm())    ## error residual mediante QR","kernel":"sagemath","output":{"0":{"name":"stdout","text":"6.568167990716596e-16\n2.2562397986482602e-15\n7.850462293418876e-16\n1.5172857927482997e-05\n"}},"pos":60,"start":1619849959359,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959403,"exec_count":42,"id":"1e5a3d","input":"A = matrix(RDF, [[1, 2, -1], [3, 4, 0], [-1, 0, 1]])\nb = vector(RDF, [2, -1, 3]);\nshow(A)\nshow(b)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n1.0 & 2.0 & -1.0 \\\\\n3.0 & 4.0 & 0.0 \\\\\n-1.0 & 0.0 & 1.0\n\\end{array}\\right)</script></html>","text/plain":"[ 1.0  2.0 -1.0]\n[ 3.0  4.0  0.0]\n[-1.0  0.0  1.0]"}},"1":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(2.0,\\,-1.0,\\,3.0\\right)</script></html>","text/plain":"(2.0, -1.0, 3.0)"}}},"pos":62,"start":1619849959379,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959451,"exec_count":43,"id":"83f38c","input":"Q, R = factorizacion_QR(A)\nshow(Q)\nshow(R)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.30151134457776363 & 0.4923659639173309 & -0.8164965809277261 \\\\\n0.9045340337332909 & 0.12309149097933261 & 0.4082482904638632 \\\\\n-0.30151134457776363 & 0.8616404368553291 & 0.4082482904638631\n\\end{array}\\right)</script></html>","text/plain":"[ 0.30151134457776363   0.4923659639173309  -0.8164965809277261]\n[  0.9045340337332909  0.12309149097933261   0.4082482904638632]\n[-0.30151134457776363   0.8616404368553291   0.4082482904638631]"}},"1":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n3.3166247903554003 & 4.221158824088691 & -0.6030226891555273 \\\\\n0.0 & 1.4770978917519924 & 0.3692744729379982 \\\\\n0.0 & 0.0 & 1.2247448713915892\n\\end{array}\\right)</script></html>","text/plain":"[ 3.3166247903554003   4.221158824088691 -0.6030226891555273]\n[                0.0  1.4770978917519924  0.3692744729379982]\n[                0.0                 0.0  1.2247448713915892]"}}},"pos":63,"start":1619849959411,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959476,"exec_count":44,"id":"c87c47","input":"bq = Q.transpose()*b; show(bq)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(-1.2060453783110545,\\,3.4465617474213164,\\,-0.8164965809277265\\right)</script></html>","text/plain":"(-1.2060453783110545, 3.4465617474213164, -0.8164965809277265)"}}},"pos":64,"start":1619849959462,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959568,"exec_count":45,"id":"63b0f4","input":"sustitucion_regresiva2(R, bq)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"(-3.666666666666667, 2.500000000000001, -0.666666666666667)"},"exec_count":45}},"pos":65,"start":1619849959486,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959695,"exec_count":46,"id":"7f6d15","input":"A.solve_right(b)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"(-3.6666666666666674, 2.5000000000000004, -0.6666666666666669)"},"exec_count":46}},"pos":67,"start":1619849959689,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959765,"exec_count":47,"id":"60dd6f","input":"A = matrix(RDF, [[1, 2, -1], [3, 4, 0], [-1, 0, 1]])  ### hemos usado el tipo RDF\nshow(A)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n1.0 & 2.0 & -1.0 \\\\\n3.0 & 4.0 & 0.0 \\\\\n-1.0 & 0.0 & 1.0\n\\end{array}\\right)</script></html>","text/plain":"[ 1.0  2.0 -1.0]\n[ 3.0  4.0  0.0]\n[-1.0  0.0  1.0]"}}},"pos":70,"start":1619849959751,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959808,"exec_count":48,"id":"0f643d","input":"U, D, V = A.SVD()\nshow(D)\nshow(U)\nshow(V)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n5.520839421931228 & 0.0 & 0.0 \\\\\n0.0 & 1.3776994213725522 & 0.0 \\\\\n0.0 & 0.0 & 0.788844966770898\n\\end{array}\\right)</script></html>","text/plain":"[ 5.520839421931228                0.0                0.0]\n[               0.0 1.3776994213725522                0.0]\n[               0.0                0.0  0.788844966770898]"}},"1":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n-0.4151229007686267 & 0.42688677935578045 & 0.8033932131084324 \\\\\n-0.9012628450527317 & -0.31341613739142543 & -0.29915816711247517 \\\\\n0.12408973118230823 & -0.8482558590625172 & 0.5148434093792152\n\\end{array}\\right)</script></html>","text/plain":"[ -0.4151229007686267  0.42688677935578045   0.8033932131084324]\n[ -0.9012628450527317 -0.31341613739142543 -0.29915816711247517]\n[ 0.12408973118230823  -0.8482558590625172   0.5148434093792152]"}},"2":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n-0.5874108843351766 & 0.24308221448650816 & -0.7719193545733267 \\\\\n-0.8033736978708719 & -0.290259968648128 & 0.5199421623312244 \\\\\n0.09766859543295936 & -0.9255593917197985 & -0.3657877224093639\n\\end{array}\\right)</script></html>","text/plain":"[-0.5874108843351766 0.24308221448650816 -0.7719193545733267]\n[-0.8033736978708719  -0.290259968648128  0.5199421623312244]\n[0.09766859543295936 -0.9255593917197985 -0.3657877224093639]"}}},"pos":71,"start":1619849959775,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959851,"exec_count":49,"id":"820a4a","input":"U*D*V.transpose() == A  ### nunca se da la igualdad exacta debido a errores numéricos","kernel":"sagemath","output":{"0":{"data":{"text/plain":"False"},"exec_count":49}},"pos":73,"start":1619849959823,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959874,"exec_count":50,"id":"171785","input":"show((U*D*V.transpose() - A).zero_at(10^-15))   ### la igualdad se tiene para un nivel de tolerancia adecuado","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]"}}},"pos":74,"start":1619849959864,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959914,"exec_count":51,"id":"5c1797","input":"show(U.transpose()*U - 1) # comprobamos que U es ortogonal.","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n8.881784197001252 \\times 10^{-16} & -5.819742391015935 \\times 10^{-17} & -9.668422317765297 \\times 10^{-17} \\\\\n-5.819742391015935 \\times 10^{-17} & 6.661338147750939 \\times 10^{-16} & -4.1184296272802975 \\times 10^{-17} \\\\\n-9.668422317765297 \\times 10^{-17} & -4.1184296272802975 \\times 10^{-17} & 8.881784197001252 \\times 10^{-16}\n\\end{array}\\right)</script></html>","text/plain":"[  8.881784197001252e-16  -5.819742391015935e-17  -9.668422317765297e-17]\n[ -5.819742391015935e-17   6.661338147750939e-16 -4.1184296272802975e-17]\n[ -9.668422317765297e-17 -4.1184296272802975e-17   8.881784197001252e-16]"}}},"pos":75,"start":1619849959887,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959953,"exec_count":52,"id":"2d44a2","input":"show((U.transpose()*U - 1).zero_at(10^-15))","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]"}}},"pos":76,"start":1619849959924,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849959984,"exec_count":53,"id":"369b94","input":"show(V.transpose()*V - 1) # comprobamos que V es ortogonal.","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n2.220446049250313 \\times 10^{-16} & 1.1630203825092376 \\times 10^{-16} & -2.4093600008735167 \\times 10^{-17} \\\\\n1.1630203825092376 \\times 10^{-16} & 4.440892098500626 \\times 10^{-16} & -2.1490713097641657 \\times 10^{-17} \\\\\n-2.4093600008735167 \\times 10^{-17} & -2.1490713097641657 \\times 10^{-17} & 4.440892098500626 \\times 10^{-16}\n\\end{array}\\right)</script></html>","text/plain":"[  2.220446049250313e-16  1.1630203825092376e-16 -2.4093600008735167e-17]\n[ 1.1630203825092376e-16   4.440892098500626e-16 -2.1490713097641657e-17]\n[-2.4093600008735167e-17 -2.1490713097641657e-17   4.440892098500626e-16]"}}},"pos":77,"start":1619849959961,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960003,"exec_count":54,"id":"ed6785","input":"show((V.transpose()*V - 1).zero_at(10^-15))","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrr}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{array}\\right)</script></html>","text/plain":"[0.0 0.0 0.0]\n[0.0 0.0 0.0]\n[0.0 0.0 0.0]"}}},"pos":78,"start":1619849959992,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960037,"exec_count":55,"id":"f5b4de","input":"def rango_SVD(A, tol = 10^(-14)):\n    U, D, V = A.SVD()\n    return len([s for s in D.diagonal() if s > tol])","kernel":"sagemath","pos":81,"start":1619849960011,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960065,"exec_count":56,"id":"d2edd8","input":"A = random_matrix(RDF, 10)\nA[3] = 0.1*A[7] - 4.2*A[5]  # cambiamos la fila 4 por una combinación lineal de las filas 6 y 8\nA[4] = -0.2*A[9] + 3.7*A[2] # cambiamos la fila 5 por una combinación lineal de las filas 3 y 10","kernel":"sagemath","pos":83,"start":1619849960042,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960099,"exec_count":57,"id":"94e493","input":"A.det()   ### el determinante no es idéntico a cero","kernel":"sagemath","output":{"0":{"data":{"text/plain":"-7.6518707915038995e-31"},"exec_count":57}},"pos":84,"start":1619849960072,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960124,"exec_count":58,"id":"8279f9","input":"F, U = forma_escalonada(A)   ### nuestro algoritmo de escalonamiento devuelve 10 pivotes, por lo que el rango sería 10\nshow(U)","kernel":"sagemath","output":{"0":{"name":"stdout","text":"\n"},"1":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrrrrrrrrr}\n0.44070113566814473 & -0.1748804644781068 & -0.7376726746857927 & -0.6740913534626689 & -0.2620117010666887 & -0.8150873153934901 & 0.24143010307756363 & 0.3695565059515955 & -0.0029628893534692224 & 0.32834429926945496 \\\\\n0.0 & 1.3019728790496417 & 0.7515705311639678 & 1.531031359939403 & 0.19388123635462906 & 2.73060552619581 & -0.12183938891371948 & 0.022668493145615254 & -0.6984800260533235 & -1.5722658316682905 \\\\\n0.0 & 0.0 & -0.2737234324646911 & -0.7274799719155755 & 0.35797516776560756 & -0.8591889628807627 & 0.14327598467826533 & 0.893967978632107 & 0.07356785192910731 & -0.22430272165147774 \\\\\n0.0 & 0.0 & 0.0 & -19.498434030337577 & 9.43653450540405 & -16.014370900703053 & 3.598216652962959 & 18.705939242235015 & 2.9952230206917942 & -8.039645184132766 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & -0.0888916215004357 & 0.06769689890281014 & 0.14996762125972357 & 0.14794456653238502 & 0.10320939298817673 & -0.15463805896732258 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.024577477972406135 & -0.036193043787222 & -0.01611855341986932 & -0.026139889300891336 & 0.007504572983413879 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.7642352474742624 & 2.5582909020065645 & 0.5758711606368349 & -1.2644925959294253 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & -1.9929447010164872 \\times 10^{-13} & -1.277849329715066 \\times 10^{-15} & 6.607090013976481 \\times 10^{-14} \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & -0.198294691437155 & -1.293876846496973 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & -5.230828137762372 \\times 10^{-15}\n\\end{array}\\right)</script></html>","text/plain":"[    0.44070113566814473     -0.1748804644781068     -0.7376726746857927     -0.6740913534626689     -0.2620117010666887     -0.8150873153934901     0.24143010307756363      0.3695565059515955  -0.0029628893534692224     0.32834429926945496]\n[                    0.0      1.3019728790496417      0.7515705311639678       1.531031359939403     0.19388123635462906        2.73060552619581    -0.12183938891371948    0.022668493145615254     -0.6984800260533235     -1.5722658316682905]\n[                    0.0                     0.0     -0.2737234324646911     -0.7274799719155755     0.35797516776560756     -0.8591889628807627     0.14327598467826533       0.893967978632107     0.07356785192910731    -0.22430272165147774]\n[                    0.0                     0.0                     0.0     -19.498434030337577        9.43653450540405     -16.014370900703053       3.598216652962959      18.705939242235015      2.9952230206917942      -8.039645184132766]\n[                    0.0                     0.0                     0.0                     0.0     -0.0888916215004357     0.06769689890281014     0.14996762125972357     0.14794456653238502     0.10320939298817673    -0.15463805896732258]\n[                    0.0                     0.0                     0.0                     0.0                     0.0    0.024577477972406135      -0.036193043787222    -0.01611855341986932   -0.026139889300891336    0.007504572983413879]\n[                    0.0                     0.0                     0.0                     0.0                     0.0                     0.0      0.7642352474742624      2.5582909020065645      0.5758711606368349     -1.2644925959294253]\n[                    0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0 -1.9929447010164872e-13  -1.277849329715066e-15   6.607090013976481e-14]\n[                    0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0      -0.198294691437155      -1.293876846496973]\n[                    0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0                     0.0  -5.230828137762372e-15]"}}},"pos":85,"start":1619849960107,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960152,"exec_count":59,"id":"f819b5","input":"UU = A.echelon_form()  # calculamos la forma canónica escalonada implementada en SageMath\nshow(UU.zero_at(10^-14))","kernel":"sagemath","output":{"0":{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left(\\begin{array}{rrrrrrrrrr}\n1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.9999999999999999 & 0.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.9999999999999999 & 0.0 \\\\\n0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0\n\\end{array}\\right)</script></html>","text/plain":"[               1.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0]\n[               0.0                1.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0]\n[               0.0                0.0                1.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0]\n[               0.0                0.0                0.0                1.0                0.0                0.0                0.0                0.0                0.0                0.0]\n[               0.0                0.0                0.0                0.0                1.0                0.0                0.0                0.0                0.0                0.0]\n[               0.0                0.0                0.0                0.0                0.0 0.9999999999999999                0.0                0.0                0.0                0.0]\n[               0.0                0.0                0.0                0.0                0.0                0.0                1.0                0.0                0.0                0.0]\n[               0.0                0.0                0.0                0.0                0.0                0.0                0.0                1.0                0.0                0.0]\n[               0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0 0.9999999999999999                0.0]\n[               0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0                0.0                1.0]"}}},"pos":86,"start":1619849960131,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960184,"exec_count":60,"id":"b963ff","input":"UU.diagonal()","kernel":"sagemath","output":{"0":{"data":{"text/plain":"[1.0,\n 1.0,\n 1.0,\n 1.0,\n 1.0,\n 0.9999999999999999,\n 1.0,\n 1.0,\n 0.9999999999999999,\n 1.0]"},"exec_count":60}},"pos":87,"start":1619849960164,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960212,"exec_count":61,"id":"8f13b6","input":"A.rank()","kernel":"sagemath","output":{"0":{"data":{"text/plain":"10"},"exec_count":61}},"pos":89,"start":1619849960190,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960232,"exec_count":62,"id":"e96506","input":"U, D, V = A.SVD()","kernel":"sagemath","pos":91,"start":1619849960216,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960280,"exec_count":63,"id":"26e915","input":"D.diagonal()  # mostramos los valores singulares ordenados de mayor a menor","kernel":"sagemath","output":{"0":{"data":{"text/plain":"[8.399819591670294,\n 5.492868228864821,\n 2.742758556117481,\n 1.8917627000140345,\n 1.5585601901416704,\n 1.0446128544774138,\n 0.697049983402088,\n 0.47295860596058936,\n 1.871846914211552e-16,\n 9.005873762772225e-17]"},"exec_count":63}},"pos":92,"start":1619849960240,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960475,"exec_count":64,"id":"d79929","input":"rango_SVD(A)","kernel":"sagemath","output":{"0":{"data":{"text/plain":"8"},"exec_count":64}},"pos":94,"start":1619849960467,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960562,"exec_count":65,"id":"7cd7a6","input":"nombre_fichero = 'Lena256.png'  ######   el nombre del fichero debe ir entre comillas\n\n\n###### no hay que modificar este codigo, el cual almacena en la matriz A los datos de la imagen elegida.\n\nimport pylab \nimagen      = pylab.imread(nombre_fichero)\nimagenmedia = pylab.mean(imagen, 2)\nA           = matrix(imagenmedia)\nm = A.nrows(); n = A.ncols()\nprint('matriz de orden:',m,'x',n)","kernel":"sagemath","output":{"0":{"name":"stdout","text":"('matriz de orden:', 256, 'x', 256)\n"}},"pos":97,"start":1619849960544,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849960983,"exec_count":66,"id":"49bdb0","input":"show(matrix_plot(A, figsize = 4, cmap = 'gray') ) \n### podemos eliminar el parámetro cmap='gray' para conseguir tonalidades invertidas","kernel":"sagemath","output":{"0":{"data":{"image/png":"179c7ac6b77a01ae1286d74669366340416c070f","text/plain":"Graphics object consisting of 1 graphics primitive"}}},"pos":99,"start":1619849960572,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961012,"exec_count":67,"id":"607627","input":"U, D, V = A.SVD()","kernel":"sagemath","pos":101,"start":1619849960992,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961224,"exec_count":68,"id":"fc71dc","input":"list_plot(D.diagonal())","kernel":"sagemath","output":{"0":{"data":{"image/png":"b9a4bc83575607703783eb1e7d2a6b13912894d9","text/plain":"Graphics object consisting of 1 graphics primitive"},"exec_count":68}},"pos":103,"start":1619849961018,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961450,"exec_count":69,"id":"32aef4","input":"list_plot(D.diagonal()[10:])","kernel":"sagemath","output":{"0":{"data":{"image/png":"7505d8beb7f576f60ba76c9073203fdd296fe5c0","text/plain":"Graphics object consisting of 1 graphics primitive"},"exec_count":69}},"pos":105,"start":1619849961234,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961710,"exec_count":70,"id":"f3b4f2","input":"k = 50  ### tan solo hay que modificar el valor asignado a k\n\nAk = U[:,0:k]*D[0:k,0:k]*(V[:,0:k].transpose())\nmatrix_plot(Ak, figsize = 4, cmap = 'gray')","kernel":"sagemath","output":{"0":{"data":{"image/png":"2a5d8a48de2a6bef5fcddd668e6ce91f3295271b","text/plain":"Graphics object consisting of 1 graphics primitive"},"exec_count":70}},"pos":107,"start":1619849961470,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961729,"exec_count":71,"id":"480ef8","input":"(k*(m + n + 1)/(m*n)).n()","kernel":"sagemath","output":{"0":{"data":{"text/plain":"0.391387939453125"},"exec_count":71}},"pos":109,"start":1619849961716,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849961756,"exec_count":72,"id":"cd775b","input":"(Ak - A).norm(2)  ## nivel de tolerancia de la imagen Ak como aproximación a la imagen A","kernel":"sagemath","output":{"0":{"data":{"text/plain":"1.3564892787869294"},"exec_count":72}},"pos":111,"start":1619849961735,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849962152,"exec_count":73,"id":"10bb07","input":"k = 20  ### tan solo hay que modificar el valor asignado a k\n\nAk = U[:, 0:k]*D[0:k, 0:k]*(V[:, 0:k].transpose())\nmatrix_plot(Ak, figsize = 4, cmap = 'gray')","kernel":"sagemath","output":{"0":{"data":{"image/png":"b62586050e2a86797c52b5d8cc7b09f8ea70c1d3","text/plain":"Graphics object consisting of 1 graphics primitive"},"exec_count":73}},"pos":113,"start":1619849961764,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849962171,"exec_count":74,"id":"d30487","input":"(k*(m + n + 1)/(m*n)).n()  ## factor de compresión obtenido con Ak","kernel":"sagemath","output":{"0":{"data":{"text/plain":"0.156555175781250"},"exec_count":74}},"pos":114,"start":1619849962162,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849962207,"exec_count":75,"id":"91d3b4","input":"(Ak - A).norm(2)  ## nivel de tolerancia de la imagen Ak como aproximación a la imagen A","kernel":"sagemath","output":{"0":{"data":{"text/plain":"3.4663024461044403"},"exec_count":75}},"pos":115,"start":1619849962176,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849962836,"exec_count":76,"id":"c772cc","input":"nombre_fichero = 'Lena256.png'  ### el nombre del fichero debe ir entre comillas\n\nimport pylab \nimagen      = pylab.imread(nombre_fichero)\nimagenmedia = pylab.mean(imagen, 2)\nA = matrix(imagenmedia)\nm = A.nrows(); n = A.ncols()\nprint('matriz de orden: %s x %s'%(m,n))\nU, D, V = A.SVD()\n\nload(\"codigo_examinar_html.sage\") ## para definir show_html\n\n@interact\ndef compresion_imagen_SVD(k = (\"num. valores singulares (calidad)\",(20,(1..floor(0.5*min(m,n))))),auto_update=False):\n    factor = 100*(k*(m + n + 1)/(m*n)).n()\n    show_html(\"<h2>Imagen comprimida usando %s valores singulares</h2>\"%k)\n    show_html(\"    Izquierda: Compresión al %.2f%%. Derecha: original\"%factor)\n    Ak = U[:, 0:k]*D[0:k, 0:k]*(V[:, 0:k].transpose())\n    g = graphics_array([matrix_plot(Ak, cmap='gray'), matrix_plot(A, cmap='gray')])\n    g.show(axes = False, figsize = [8, 3])","kernel":"sagemath","output":{"0":{"name":"stdout","text":"matriz de orden: 256 x 256\n"},"1":{"data":{"application/vnd.jupyter.widget-view+json":{"model_id":"ca7aa04d5ea849d2a03e4953d364cf5f","version_major":2,"version_minor":0},"text/plain":"TWFudWFsIGludGVyYWN0aXZlIGZ1bmN0aW9uIDxmdW5jdGlvbiBjb21wcmVzaW9uX2ltYWdlbl9TVkQgYXQgMHg3ZjNmMjRjYWNmNTA+IHdpdGggMSB3aWRnZXQKICBrOiBTZWxlY3Rpb25TbGnigKY=\n"}}},"pos":117,"start":1619849962244,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849963317,"exec_count":77,"id":"ce9521","input":"compresion_imagen_SVD(50)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<h2>Imagen comprimida usando 50 valores singulares</h2>","text/plain":"<h2>Imagen comprimida usando 50 valores singulares</h2>"}},"1":{"data":{"text/html":"    Izquierda: Compresión al 39.14%. Derecha: original","text/plain":"    Izquierda: Compresión al 39.14%. Derecha: original"}},"2":{"data":{"image/png":"2b2eb80f243c2a90735edd91e2db685d29ff5725","text/plain":"Graphics Array of size 1 x 2"}}},"pos":119,"start":1619849962862,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849964105,"exec_count":78,"id":"32fa02","input":"tol = 2  ## basta modificar tan solo el nivel de tolerancia elegido\n\n### no modificar este código\nk = 0\nnorma = tol + 1\nwhile norma > tol:\n    k = k+1\n    Ak    = U[:,0:k]*D[0:k,0:k]*(V[:,0:k].transpose())\n    norma = (A - Ak).norm(2)\nprint('NIVEL DE TOLERANCIA: ', tol)\ncompresion_imagen_SVD(k)","kernel":"sagemath","output":{"0":{"name":"stdout","text":"('NIVEL DE TOLERANCIA: ', 2)\n"},"1":{"data":{"text/html":"<h2>Imagen comprimida usando 35 valores singulares</h2>","text/plain":"<h2>Imagen comprimida usando 35 valores singulares</h2>"}},"2":{"data":{"text/html":"    Izquierda: Compresión al 27.40%. Derecha: original","text/plain":"    Izquierda: Compresión al 27.40%. Derecha: original"}},"3":{"data":{"image/png":"2a56820edc2f85bf42217116c4df03e8cbf899bb","text/plain":"Graphics Array of size 1 x 2"}}},"pos":121,"start":1619849963330,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849964136,"exec_count":79,"id":"ccf015","input":"print((A - Ak).norm(2))\n(A - Ak).norm(2) < tol","kernel":"sagemath","output":{"0":{"name":"stdout","text":"1.9507802009667996\n"},"1":{"data":{"text/plain":"True"},"exec_count":79}},"pos":122,"start":1619849964111,"state":"done","type":"cell"}
{"cell_type":"code","end":1619849964209,"exec_count":80,"id":"8f19a6","input":"NUMERO_CUESTIONARIO = 200 # Cambiar al número de cuestionario proporcionado por el profesorado.\n\n\n####  NO MODIFICAR EL CÓDIGO DE ABAJO:  ########################\n\nNOMBRE_FICHERO_EXAMEN = 'ALN_L5_t.htl'\n\nload('show_html.sage')\nload('codigo_examinar_html.sage')\n\nif NUMERO_CUESTIONARIO > 0:\n    lector_examenes(NOMBRE_FICHERO_EXAMEN, NUMERO_CUESTIONARIO, False)","kernel":"sagemath","output":{"0":{"data":{"text/html":"<center><h4>E.T.S.I.I. - GRADOS EN INGENIERÍA INFORMÁTICA</h4></center><center><h4>Álgebra Lineal y Numérica - QUINTA PRÁCTICA DE LABORATORIO</h4></center><hr  align=center><center>APELLIDOS, NOMBRE: <INPUT value= \"\",type=text size=70> <INPUT type=submit value=200-132C26><hr  align=center></center><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 1 </span></b><br> Dado el sistema lineal de matriz ampliada <script type=\"math/tex; mode=display\">\\displaystyle (A|b)=\\left(\\begin{array}{rrrrrr}0, &1, &0, &1, &1, &4, \\\\0, &3, &1, &0, &196, &-374, \\\\2, &7, &0, &1, &6, &28, \\\\-654, &1, &-1, &1, &2, &656, \\\\-2, &-1, &0, &48, &1, &-6\\end{array}\\right) ,</script> se pide:<ol><li>Guardar los datos de la matriz <script type=\"math/tex\">A</script> y el vector <script type=\"math/tex\">b</script> empleando el anillo de números RDF.\nEncontrar la solución del sistema <script type=\"math/tex\">Ax=b</script> mediante la factorización PLU.</li><li>Calcular la proporción <script type=\"math/tex\">\\kappa (L)*\\kappa (U)/ \\kappa (A)</script> entre el producto de los números de condición de <script type=\"math/tex\">L</script> y <script type=\"math/tex\">U</script>\n y el número de condición de <script type=\"math/tex\">A</script>, todos calculados para la norma euclídea.</li><li>Encontrar la solución del sistema <script type=\"math/tex\">Ax=b</script> mediante la factorización QR.</li></ol>Marcar la respuesta correcta, para una precisión numérica de al menos 6 cifras decimales exactas.\nAyuda: puede copiar y pegar los datos de la matriz desde el enunciado hasta instrucciones del tipo:\n    A=matrix(RDF,5,5,[pegar_datos_aqui]).transpose()\n    b=vector(RDF,[pegar_datos_aqui])\n es importante borrar y reescribir todos los signos negativos.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> (-1.000000000000002, 6.000000000000006, 1.3056881253374434e-12, 1.8449239655875015e-16, -2.0000000000000067) <br> 2.<input type=checkbox> (3.0000000000826326, 9.000000000082629, 3.0, 7.000000000000001, -8.262984095402549e-11) <br> 3.<input type=checkbox> (2.0000000000001106, 1.0231815394945443e-12, 2.999999999999659, -2.000000000000014, 6.000000000000082) <br> 4.<input type=checkbox> (1.9999999999993818, -5.000000000005262, -6.139089236967265e-12, 2.9999999999993534, 8.000000000000046)<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 2.54162366331 <br> 2.<input type=checkbox> 4.79660034699 <br> 3.<input type=checkbox> 1.5831613122 <br> 4.<input type=checkbox> 2.5468429294<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 3 </span></b><br><br> 1.<input type=checkbox> (-1.0331888849284521e-08, 5.999999984538575, -5.999999989154374, 2.0000000005893375, -4.999999598810137) <br> 2.<input type=checkbox> (1.9999999994974005, -4.647439837023477e-09, 3.0000000016221926, -1.999999999934732, 5.999999999637521) <br> 3.<input type=checkbox> (-1.0000000066448325, 6.000000021003424, 4.3225995566623785e-06, 6.271370299398876e-10, -2.0000000223755583) <br> 4.<input type=checkbox> (-6.000000000272877, 7.487836686769031e-11, -4.000000000182856, -6.999999999998196, -7.000000000003887)<br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 2 </span></b><br> Dado el sistema lineal de matriz ampliada <script type=\"math/tex; mode=display\">\\displaystyle (B|c)=\\left(\\begin{array}{rrrrrr}-1, &2, &14, &2, &-1, &107, \\\\-1, &-7, &-3, &3, &1, &-71, \\\\-7, &0, &1, &7, &0, &20, \\\\3, &7, &-1, &1, &1, &49, \\\\1, &-1, &1, &1, &-2, &6\\end{array}\\right) ,</script> se pide:<ol><li>Guardar los datos de la matriz <script type=\"math/tex\">B</script> y el vector <script type=\"math/tex\">c</script> empleando el anillo de números RDF.\nEncontrar la solución del sistema <script type=\"math/tex\">Bx=c</script> mediante la factorización PLU.</li><li>Calcular la proporción <script type=\"math/tex\">\\kappa (L)*\\kappa (U)/ \\kappa (B)</script> entre el producto de los números de condición de <script type=\"math/tex\">L</script> y <script type=\"math/tex\">U</script>\n y el número de condición de <script type=\"math/tex\">B</script>, todos calculados para la norma euclídea.</li><li>Encontrar la solución del sistema <script type=\"math/tex\">Bx=c</script> mediante la factorización QR.</li><li>Bajo el supuesto de que los sistemas <script type=\"math/tex\">Ax=b</script> del ejercicio anterior y <script type=\"math/tex\">Bx=c</script> de este ejercicio \nson dos modelizaciones diferentes del mismo problema, ¿qué vector sería más fiable tomar\ncomo aproximación a la solución del problema?</li></ol>Marcar la respuesta correcta, para una precisión numérica de al menos 6 cifras decimales exactas.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> (-1.0150610510858574e-15, 8.000000000000002, 6.0, 1.9999999999999991, -3.000000000000002) <br> 2.<input type=checkbox> (-5.921189464667502e-15, -1.9999999999999984, 5.9999999999999964, -3.0000000000000013, -1.2028873085702488e-15) <br> 3.<input type=checkbox> (1.0000000000000007, 0.0, 8.0, -2.2373960190919183e-16, -0.9999999999999999) <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 2.77718964894 <br> 2.<input type=checkbox> 4.5478593136 <br> 3.<input type=checkbox> 2.47020984937 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 3 </span></b><br><br> 1.<input type=checkbox> (5.685979684106711e-17, 8.0, 6.0, 1.9999999999999993, -3.0000000000000018) <br> 2.<input type=checkbox> (-3.000000000000005, 5.000000000000017, 1.999999999999999, -5.9910642812040376e-15, -7.389498206583381e-15) <br> 3.<input type=checkbox> (-5.000000000000008, -1.9327369419886096e-14, 5.000000000000088, 1.561082714279647e-13, -8.999999999999911) <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 4 </span></b><br><br> 1.<input type=checkbox> (4.0, 0.0, -2.0, 0.0, 3.0) <br> 2.<input type=checkbox> (0.0, 8.0, 6.0, 2.0, -3.0) <br> 3.<input type=checkbox> (0.0, 0.0, 2.0, 0.0, -6.0) <br> 4.<input type=checkbox> (-8.0, -7.0, -7.0, 0.0, -7.0)<br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 3 </span></b><br> Dada la matriz <script type=\"math/tex; mode=display\">A=\\left(\\begin{array}{rrrrrrrrrr}20, &-35, &154, &-6, &-2, &85, &32, &80, &37, &-3, \\\\15, &19, &-154, &40, &-10, &-108, &1, &-450, &13, &14, \\\\48, &-12, &122, &-16, &-7, &45, &20, &-292, &-12, &11, \\\\21, &-10, &35, &-14, &1, &-18, &17, &-40, &-18, &-7, \\\\1, &0, &-1, &6, &-1, &2, &1, &-2, &0, &-1, \\\\3, &-1, &1, &2, &-1, &-3, &1, &-47, &1, &3, \\\\-3, &1, &-1, &2, &0, &4, &-3, &12, &-1, &1, \\\\-1, &-3, &21, &-1, &0, &19, &1, &34, &6, &0, \\\\1, &-2, &6, &1, &0, &0, &1, &2, &-3, &0, \\\\-2, &-1, &-4, &8, &-1, &2, &0, &-1, &5, &1\\end{array}\\right),</script> guardarla en memoria declarando sus coeficientes en el anillo RDF. Se pide:<ol><li>Comprobar mediante escalonamiento que el rango es 10. Señalar cuál es su\n rango numérico estimado a partir de la descomposición SVD de la matriz,\n para un nivel de tolerancia por defecto de <script type=\"math/tex\">10^{-14}</script>.</li></ol>Marcar la respuesta correcta.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> <table style=\" width:100%\"> <tr> <td style=\"border:none; text-align:left\">1.<input type=checkbox> 5    </td> <td style=\"border:none; text-align:left\">2.<input type=checkbox> 9    </td> </tr> <tr> <td style=\"border:none; text-align:left\">3.<input type=checkbox> 6    </td> <td style=\"border:none; text-align:left\">4.<input type=checkbox> Ninguna de las otras respuestas.    </td> </tr> </table><br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 4 </span></b><br> Para este ejercicio se debe utilizar la imagen en blanco y negro de 256x256 pixeles denominada\n imagen8.png. Se pide:<ol><li>Para una tolerancia dada de 2.7, determinar el número k mínimo de valores singulares \nque proporciona una compresión visual con dicho nivel de tolerancia, utilizando descomposición SVD.</li><li>Determinar el valor k mínimo para obtener un factor de compresión de al menos el 47 por ciento.</li></ol>Marcar la respuesta correcta.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> 27 <br> 2.<input type=checkbox> 22 <br> 3.<input type=checkbox> 73 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 61 <br> 2.<input type=checkbox> 76 <br> 3.<input type=checkbox> 49 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><hr  align=center><center><span style=\"font-size: x-small;\"> Final del documento </span></center>","text/plain":"<center><h4>E.T.S.I.I. - GRADOS EN INGENIERÍA INFORMÁTICA</h4></center><center><h4>Álgebra Lineal y Numérica - QUINTA PRÁCTICA DE LABORATORIO</h4></center><hr  align=center><center>APELLIDOS, NOMBRE: <INPUT value= \"\",type=text size=70> <INPUT type=submit value=200-132C26><hr  align=center></center><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 1 </span></b><br> Dado el sistema lineal de matriz ampliada <script type=\"math/tex; mode=display\">\\displaystyle (A|b)=\\left(\\begin{array}{rrrrrr}0, &1, &0, &1, &1, &4, \\\\0, &3, &1, &0, &196, &-374, \\\\2, &7, &0, &1, &6, &28, \\\\-654, &1, &-1, &1, &2, &656, \\\\-2, &-1, &0, &48, &1, &-6\\end{array}\\right) ,</script> se pide:<ol><li>Guardar los datos de la matriz <script type=\"math/tex\">A</script> y el vector <script type=\"math/tex\">b</script> empleando el anillo de números RDF.\nEncontrar la solución del sistema <script type=\"math/tex\">Ax=b</script> mediante la factorización PLU.</li><li>Calcular la proporción <script type=\"math/tex\">\\kappa (L)*\\kappa (U)/ \\kappa (A)</script> entre el producto de los números de condición de <script type=\"math/tex\">L</script> y <script type=\"math/tex\">U</script>\n y el número de condición de <script type=\"math/tex\">A</script>, todos calculados para la norma euclídea.</li><li>Encontrar la solución del sistema <script type=\"math/tex\">Ax=b</script> mediante la factorización QR.</li></ol>Marcar la respuesta correcta, para una precisión numérica de al menos 6 cifras decimales exactas.\nAyuda: puede copiar y pegar los datos de la matriz desde el enunciado hasta instrucciones del tipo:\n    A=matrix(RDF,5,5,[pegar_datos_aqui]).transpose()\n    b=vector(RDF,[pegar_datos_aqui])\n es importante borrar y reescribir todos los signos negativos.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> (-1.000000000000002, 6.000000000000006, 1.3056881253374434e-12, 1.8449239655875015e-16, -2.0000000000000067) <br> 2.<input type=checkbox> (3.0000000000826326, 9.000000000082629, 3.0, 7.000000000000001, -8.262984095402549e-11) <br> 3.<input type=checkbox> (2.0000000000001106, 1.0231815394945443e-12, 2.999999999999659, -2.000000000000014, 6.000000000000082) <br> 4.<input type=checkbox> (1.9999999999993818, -5.000000000005262, -6.139089236967265e-12, 2.9999999999993534, 8.000000000000046)<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 2.54162366331 <br> 2.<input type=checkbox> 4.79660034699 <br> 3.<input type=checkbox> 1.5831613122 <br> 4.<input type=checkbox> 2.5468429294<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 3 </span></b><br><br> 1.<input type=checkbox> (-1.0331888849284521e-08, 5.999999984538575, -5.999999989154374, 2.0000000005893375, -4.999999598810137) <br> 2.<input type=checkbox> (1.9999999994974005, -4.647439837023477e-09, 3.0000000016221926, -1.999999999934732, 5.999999999637521) <br> 3.<input type=checkbox> (-1.0000000066448325, 6.000000021003424, 4.3225995566623785e-06, 6.271370299398876e-10, -2.0000000223755583) <br> 4.<input type=checkbox> (-6.000000000272877, 7.487836686769031e-11, -4.000000000182856, -6.999999999998196, -7.000000000003887)<br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 2 </span></b><br> Dado el sistema lineal de matriz ampliada <script type=\"math/tex; mode=display\">\\displaystyle (B|c)=\\left(\\begin{array}{rrrrrr}-1, &2, &14, &2, &-1, &107, \\\\-1, &-7, &-3, &3, &1, &-71, \\\\-7, &0, &1, &7, &0, &20, \\\\3, &7, &-1, &1, &1, &49, \\\\1, &-1, &1, &1, &-2, &6\\end{array}\\right) ,</script> se pide:<ol><li>Guardar los datos de la matriz <script type=\"math/tex\">B</script> y el vector <script type=\"math/tex\">c</script> empleando el anillo de números RDF.\nEncontrar la solución del sistema <script type=\"math/tex\">Bx=c</script> mediante la factorización PLU.</li><li>Calcular la proporción <script type=\"math/tex\">\\kappa (L)*\\kappa (U)/ \\kappa (B)</script> entre el producto de los números de condición de <script type=\"math/tex\">L</script> y <script type=\"math/tex\">U</script>\n y el número de condición de <script type=\"math/tex\">B</script>, todos calculados para la norma euclídea.</li><li>Encontrar la solución del sistema <script type=\"math/tex\">Bx=c</script> mediante la factorización QR.</li><li>Bajo el supuesto de que los sistemas <script type=\"math/tex\">Ax=b</script> del ejercicio anterior y <script type=\"math/tex\">Bx=c</script> de este ejercicio \nson dos modelizaciones diferentes del mismo problema, ¿qué vector sería más fiable tomar\ncomo aproximación a la solución del problema?</li></ol>Marcar la respuesta correcta, para una precisión numérica de al menos 6 cifras decimales exactas.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> (-1.0150610510858574e-15, 8.000000000000002, 6.0, 1.9999999999999991, -3.000000000000002) <br> 2.<input type=checkbox> (-5.921189464667502e-15, -1.9999999999999984, 5.9999999999999964, -3.0000000000000013, -1.2028873085702488e-15) <br> 3.<input type=checkbox> (1.0000000000000007, 0.0, 8.0, -2.2373960190919183e-16, -0.9999999999999999) <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 2.77718964894 <br> 2.<input type=checkbox> 4.5478593136 <br> 3.<input type=checkbox> 2.47020984937 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 3 </span></b><br><br> 1.<input type=checkbox> (5.685979684106711e-17, 8.0, 6.0, 1.9999999999999993, -3.0000000000000018) <br> 2.<input type=checkbox> (-3.000000000000005, 5.000000000000017, 1.999999999999999, -5.9910642812040376e-15, -7.389498206583381e-15) <br> 3.<input type=checkbox> (-5.000000000000008, -1.9327369419886096e-14, 5.000000000000088, 1.561082714279647e-13, -8.999999999999911) <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 4 </span></b><br><br> 1.<input type=checkbox> (4.0, 0.0, -2.0, 0.0, 3.0) <br> 2.<input type=checkbox> (0.0, 8.0, 6.0, 2.0, -3.0) <br> 3.<input type=checkbox> (0.0, 0.0, 2.0, 0.0, -6.0) <br> 4.<input type=checkbox> (-8.0, -7.0, -7.0, 0.0, -7.0)<br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 3 </span></b><br> Dada la matriz <script type=\"math/tex; mode=display\">A=\\left(\\begin{array}{rrrrrrrrrr}20, &-35, &154, &-6, &-2, &85, &32, &80, &37, &-3, \\\\15, &19, &-154, &40, &-10, &-108, &1, &-450, &13, &14, \\\\48, &-12, &122, &-16, &-7, &45, &20, &-292, &-12, &11, \\\\21, &-10, &35, &-14, &1, &-18, &17, &-40, &-18, &-7, \\\\1, &0, &-1, &6, &-1, &2, &1, &-2, &0, &-1, \\\\3, &-1, &1, &2, &-1, &-3, &1, &-47, &1, &3, \\\\-3, &1, &-1, &2, &0, &4, &-3, &12, &-1, &1, \\\\-1, &-3, &21, &-1, &0, &19, &1, &34, &6, &0, \\\\1, &-2, &6, &1, &0, &0, &1, &2, &-3, &0, \\\\-2, &-1, &-4, &8, &-1, &2, &0, &-1, &5, &1\\end{array}\\right),</script> guardarla en memoria declarando sus coeficientes en el anillo RDF. Se pide:<ol><li>Comprobar mediante escalonamiento que el rango es 10. Señalar cuál es su\n rango numérico estimado a partir de la descomposición SVD de la matriz,\n para un nivel de tolerancia por defecto de <script type=\"math/tex\">10^{-14}</script>.</li></ol>Marcar la respuesta correcta.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> <table style=\" width:100%\"> <tr> <td style=\"border:none; text-align:left\">1.<input type=checkbox> 5    </td> <td style=\"border:none; text-align:left\">2.<input type=checkbox> 9    </td> </tr> <tr> <td style=\"border:none; text-align:left\">3.<input type=checkbox> 6    </td> <td style=\"border:none; text-align:left\">4.<input type=checkbox> Ninguna de las otras respuestas.    </td> </tr> </table><br><br><hr  align=center><b> <span style=\"color: #0000ff;\">EJERCICIO 4 </span></b><br> Para este ejercicio se debe utilizar la imagen en blanco y negro de 256x256 pixeles denominada\n imagen8.png. Se pide:<ol><li>Para una tolerancia dada de 2.7, determinar el número k mínimo de valores singulares \nque proporciona una compresión visual con dicho nivel de tolerancia, utilizando descomposición SVD.</li><li>Determinar el valor k mínimo para obtener un factor de compresión de al menos el 47 por ciento.</li></ol>Marcar la respuesta correcta.<br><hr  align=center><b> <span style=\"color: #ff0000;\">Respuesta al apartado 1 </span></b><br><br> 1.<input type=checkbox> 27 <br> 2.<input type=checkbox> 22 <br> 3.<input type=checkbox> 73 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><b> <span style=\"color: #ff0000;\">Respuesta al apartado 2 </span></b><br><br> 1.<input type=checkbox> 61 <br> 2.<input type=checkbox> 76 <br> 3.<input type=checkbox> 49 <br> 4.<input type=checkbox> Ninguna de las otras respuestas.<br><br><hr  align=center><center><span style=\"font-size: x-small;\"> Final del documento </span></center>"}}},"pos":124,"start":1619849964145,"state":"done","type":"cell"}
{"cell_type":"code","id":"659031","input":"","pos":125,"type":"cell"}
{"cell_type":"markdown","id":"052348","input":"<p>Ahora hallamos la solución aportada mediante escalonamiento directo del sistema:</p>","pos":52,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"05d593","input":"<p>En este ejemplo, los errores numéricos son considerablemente grandes. En consecuencia, tal descomposición obtenida no puede utilizarse en cálculos prácticos poque no tendrían validez o fiabilidad.</p>\n<p>Podemos intentar identificar las matrices que tienen un mal comportamiento numérico con ayuda del estudio del <span style=\"background-color: #ffffff; color: #ff0000;\"><em>número de condición</em></span> de tales matrices. El número de condición de una matriz $A$, que notaremos <span style=\"color: #ff0000;\">$\\kappa(A)$</span>, estima cuánto se amplifican como máximo los errores relativos sobre los datos cuando resolvemos sistemas $Ax=b$ (es decir, sistemas con matriz de coeficientes igual a $A$, cuadrada y no singular).</p>\n<p>La siguiente función proporciona el número de condición de una matriz $A$ regular, para la norma especificada:</p>\n<p style=\"text-align: center;\"><span style=\"color: #0000ff;\">numero_condicion(A, p)</span></p>\n<p>donde</p>\n<ul>\n<li>p=1 se refiere a la norma-1,</li>\n<li>p=2 para la norma euclídea (valor por defecto).</li>\n<li>y p=Infinity para la  norma infinito.</li>\n</ul>\n<p>Si la matriz es singular o se utiliza otra norma diferente, se imprime un mensaje de error.</p>","pos":30,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"11aba9","input":"<p>Finalmente, mediante descomposición $A=QR$ obtenida por el método de Gram-Schmidt:</p>","pos":56,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"165a4a","input":"<p>Luego los errores de transmisión en la descomposición $PA=LU$ podrían llegar a ser bastante mayores que en la descomposición $A=QR$.</p>\n<p>Probamos ahora con la matriz de Hilbert de orden 20:</p>","pos":44,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1a72a9","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 6</span></h3>\n<p><em>Generar una matriz  aleatoria A, cuadrada y de orden 10. Modificar dos filas mediante las siguientes transformaciones:</em></p>\n<div id=\"_mcePaste\" style=\"position: absolute; left: -10000px; top: 16px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden;\"><em>A[3]=0.1*A[7]-4.2*A[5]</em></div>\n<div id=\"_mcePaste\" style=\"position: absolute; left: -10000px; top: 16px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden;\"><em>A[4]=-0.1*A[9]+4.2*A[2]</em></div>\n<p><em>A[3]=0.1*A[7]-4.2*A[5]</em></p>\n<p><em>A[4]=-0.2*A[9]+3.7*A[2]</em></p>\n<p><em>Obviamente como la matriz $A$ tiene al menos dos filas combinaciones lineales de otras, su determinante debe ser nulo y su rango menor o igual a 8.</em></p>\n<p><em>a) Hacer las comprobaciones oportunas mediante las ordenes  <strong>A.det()</strong> (que nos proporciona el determinante) y <strong>A.echelon_form()</strong> (que nos devuelve la forma escalonada canónica)  para ver el rango de A. ¿Qué sucede?</em></p>\n<p><em>b) Deducir el rango de A  a partir de la descomposición SVD de la matriz.</em></p>\n<p><em>c) Utilizar la instrucción <span style=\"color: #0000ff;\">rango_SVD(A)</span> para comprobar el resultado.</em></p>","pos":82,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1aff65","input":"<p>Comprobamos que el rango coincide con el número de columnas:</p>","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1dc834","input":"<p>Calculamos el factor de compresión:</p>","pos":108,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1f4b80","input":"<div style=\"color: #000000; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; background-position: initial initial; background-repeat: initial initial; margin: 8px;\">\n<p>Obviamente, se obtiene una peor aproximación (mayor error)  tomando 20 valores que si tomamos 50 valores singulares.</p>\n<p>El siguiente script permite automatizar el proceso de cálculo de los $A_k$, obtener el factor de compresión y comparar visualmente el resultado con la imagen original:</p>\n</div>","pos":116,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2160fa","input":"<hr>\n\n<h3><a name=\"cuestionario\"></a></h3>\n<h3>CUESTIONARIO PARA EL ALUMNADO</h3>\n\nIntroduzca en la variable NUMERO_CUESTIONARIO, que aparece más abajo, el número correspondiente a su cuestionario asignado y ejecuta la celda (*Shift* + *Enter* desde dentro de la celda). Accederá a un cuestionario con respuestas tipo test que se entregará cumplimentado antes de finalizar esta sesión práctica, siguiendo un modelo impreso que entregará el profesor y/o on-line en la plataforma de enseñanza virtual (seguir las instrucciones dadas en la clase de laboratorio por el docente).\n\n**Ayuda para copiar los datos de los enunciados:**\n\n* Se puede utilizar la función `matrix_from_copypaste` para copiar y pegar los coeficientes de las matrices. Selecciona con el ratón todos los datos del interior de la matriz y cópialos con Ctrl+C. Luego, pégalos (entre comillas) con Ctrl+V en el interior de la siguiente orden:\n      A = matrix_from_copypaste(RDF, 5, 5, 'pegar_aqui_los_coeficientes' )   # matriz de orden 5x5 para datos en RDF.\n* De forma análoga, se puede utilizar la función `vector_from_copypaste` para copiar y pegar los coeficientes de los vectores.\n      b = vector_from_copypaste(RDF, 'pegar_aqui_los_coeficientes' )    # vector para datos en RDF.\n\n_Observaciones:_\n* Aunque los enunciados contienen instrucciones para copiar y pegar los datos, es más cómodo usar la función `matrix_from_copypaste`.\n* Utilizar el formato `RDF` (*Real Double Field*) para almacenar los números en coma flotante.\n* Prestar especial atención a la tolerancia numérica proporcionada en los enunciados a la hora de elegir una respuesta tipo test.","pos":123,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"280d5a","input":"<p>Comprobamos si la factorización $QR$ es correcta:</p>","pos":9,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"3021eb","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 2</span></h3>\n<p><em>Sea  $H_{15}$ la matriz de Hilbert de orden $15$ (los coeficientes $h_{ij}$ de $H_{n}$ vienen definidos como $h_{ij}= 1/(i+j-1)$) .</em></p>\n<p><em>Calcular la descomposición $QR$ para la matriz $H_{15}$ y analizar los errores cometidos.</em></p>\n\n<p>Facilitamos una función que genera la matriz de Hilbert de orden n</p>","pos":24,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"30a3b4","input":"<p>Comparamos con la solución obtenida mediante  solve_right:</p>","pos":66,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"31a336","input":"<p>Vamos a visualizar $A_{50}$:</p>","pos":106,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"32c81d","input":"<p>Hallamos la descomposición $A=UDV^t$:</p>","pos":100,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4a63df","input":"<p>Con objeto de diferenciar mejor los valores más pequeños, vamos a representar nuevamente los mismos pero prescindiendo de los 10 primeros valores:</p>","pos":104,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4acf39","input":"<h3><strong>Una aplicación de la descomposición SVD a la compresión de imágenes </strong></h3>\n<p>Vamos a analizar una sencilla, y rudimentaria, aplicación de la descomposición SVD de una matriz al problema de <strong>compresión de imágenes (con pérdida de calidad)</strong>.</p>\n<p>Una fotografía digital en blanco y negro a resolución $m\\times n$ píxeles se puede interpretar matemáticamente como una matriz de dimensión $m\\times n$ cuyos elementos, que están en el intervalo $[0,1]$, indican la tonalidad de gris de un pixel de la pantalla del ordenador, en una gama de grises que va desde el negro (0) hasta el blanco (1). Sea $A=(a_{ij})$ la matriz asociada a una fotografía en blanco y negro de dimensión $m\\times n$. Aproximaremos $A$ por matrices $A_1$, $A_2$, $A_3$, $\\ldots$, $A_k \\ldots$ que pueden almacenarse en menos espacio de memoria.</p>\n<p>Sean $\\sigma_1 \\le \\cdots \\le  \\sigma_r$ los valores singulares no nulos de $A$ ordenados de mayor  a menor. Así, se tiene que existen matrices ortogonales $U$ y $V$ tales que</p>\n<p>$$ A=U \\Sigma V^t = U \\left(\\begin{array}{cccccc} \\sigma_1 &  &  & & &  \\\\ & \\ddots &  & & &  \\\\  &  &\\sigma_r &  & & \\\\  & & & 0 & &\\\\  & & & & \\ddots & \\\\  & & & & & 0\\end{array}\\right) V^t$$</p>\n<p>Para cualquier $k \\le r$, ponemos $$\\Sigma_k =\\left(\\begin{array}{cccccc} \\sigma_1 &  &  & & &  \\\\ & \\ddots &  & & &  \\\\  &  &\\sigma_k &  & & \\\\  & & & 0 & &\\\\ & & & & \\ddots & \\\\  & & & & & 0\\end{array}\\right)$$</p>\n<p>y $A_k = U \\Sigma_k V^t$.</p>\n<p>Ahora bien, cómo son no nulos los k primeros valores de la matriz $\\Sigma_k$, basta multiplicar las k primeras columnas de $U$ y las k primeras filas de $V^t$ o, equivalentemente, las k primeras columnas de $V$. De esta forma, la cantidad de datos para construir $A_k$ se reduce a $k(m+n+1)$, frente a los $m\\times n$ datos de la matriz $A$. Así, conseguimos un factor de compresión (en tanto por uno) de</p>\n<p>$$\\frac{k(m+n+1)}{mn}$$</p>\n<p>Podemos experimentar con diferentes  valores de $k$, buscando que la imagen de la fotografía $A_k$ sea visualmente equivalente a la de $A$, hasta encontrar un equilibrio adecuado entre el mayor factor de compresión posible y la calidad visual resultante. Si se trata de obtener una compresión de la imagen, no tiene sentido tomar $k$ mayor que la mitad del número de filas o  columnas de la imagen pues, de hacerlo, el número de datos no disminuiría respecto de la  matriz original.</p>","pos":95,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4b691d","input":"<p>Observamos que la matriz de Hilbert de orden 15 tiene un número de condición superior a $4\\cdot 10^{17}$, de ahí su mal comportamiento en los cálculos numéricos de su descomposición QR.</p>\n<p>Las matrices de Hilbert son conocidas en la literatura matemática por tratarse de ejemplos de matrices muy mal condicionadas para realizar cálculos numéricos con ellas.</p>\n<p>En vista de los resultados obtenidos anteriormente, el método de descomposición $QR$ por ortonormalización de Gram-Schmidt puede amplificar errores para matrices mal condicionadas, obteniéndose que la matriz $Q$ de la descomposición no es ortogonal, lo que invalida dicha descomposición. En consecuencia habría que introducir algún refinamiento o método alternativo para abordar este tipo de descomposición, que tuviera en cuenta el condicionamiento de las matrices. Estudiaremos otras formas alternativas de descomposiciones $QR$, tales como descomposición de Givens y descomposición de Householder, en un próximo tema.</p>\n\n<h3><strong><a name=\"resolucion\"></a></strong></h3>\n<h3><strong>Aplicación de la descomposición $QR$ a la resolución de sistemas lineales</strong></h3>\n<p>Dado un  sistema lineal  $Ax=b$, si la matriz $A$ <strong>cuadrada</strong> admite descomposición $A=QR$ donde $Q$ es una <strong>matriz ortogonal</strong> ($Q^t=Q^{-1}$ ) y $R$ es una matriz triangular superior, podemos hacer la siguiente transformación:</p>\n<p>\\begin{align*}Ax=b&\\Leftrightarrow QRx=b\\\\ &\\Leftrightarrow Rx=Q^t b\\end{align*}</p>\n<p>de donde resulta un sistema lineal equivalente con matriz de coeficientes triangular. El coste computacional para resolver dicho sistema es de orden $n^2$, siendo $n$ el orden de la matriz $A$, sin embargo, el coste computacional de la descomposición $QR$ a partir del método de Gram-Schmidt es superior a cualquier método de escalonamiento del sistema original de los ya estudiados.</p>\n<p>¿Dónde radica el interés?</p>\n<p>En el condicionamiento de los sistemas resultantes. Sabemos que, para la norma euclídea (o \"norma espectral\") de las matrices, el número de condición de una matriz es 1 (el mínimo posible) si y solo si dicha matriz es ortogonal y además $\\kappa(A)=\\kappa(QR)=\\kappa(R)$ por ser $Q$ matriz ortogonal. En conclusión, los sistemas $Ax=b$ y $Rx=Q^tb$ están igualmente condicionados.</p>\n<p>Esto no sucede con los métodos de escalonamiento, donde la matriz $A$ admite una descomposición del tipo $PA=LU$ siendo $P$ una matriz de permutación (y por tanto ortogonal), $L$ una matriz triangular inferior unitaria y $U$ una matriz triangular superior. En tales casos resulta $\\kappa(PA)=\\kappa(A)=\\kappa(LU)\\leq\\kappa(L)\\kappa(U)$. Al resolverse el sistema lineal $Ax=b$ en tres etapas:</p>\n1. $b'=Pb$,\n2. $Lg=b'$, \n3. $Ux=g$.\n<p>los errores de una etapa se transmiten a la siguiente, pudiendo amplificarse hasta el límite marcado por el número de condición de la matriz de cada etapa. Así, en general, $\\kappa(A)$ es bastante menor que $\\kappa(L)\\kappa(U)$ con lo que corremos el riesgo, al escalonar, que la solución final esté afectada de mayores errores que utilizando el método de descomposición $QR$.</p>","pos":33,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4c316e","input":"<p>Se han obtenido 10 pivotes, por lo que el rango sería 10. Lo comprobamos con la función rank()  que también proporciona el rango siguiendo el método de escalonamiento:</p>","pos":88,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"546670","input":"<p>Es importante no confundir $Q^tQ=I_n$ con $QQ^t$ pues esta última no tiene porqué verificar $QQ^t=I_m$.</p>","pos":22,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"5fbeb8","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 7</span></h3>\n<p>El siguiente bloque de instrucciones genera una matriz $A$ que representa una imagen digital en blanco y negro a partir de un fichero denominado Lena256.png, que está guardado en un directorio especificado en la variable global DATA.</p>","pos":96,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"67aad8","input":"<p>Comprobamos finalmente si $Q^t Q = I$:</p>","pos":17,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7d1ff8","input":"<p>El script anterior puede utilizarse como una función y llamarse desde cualquier otra celda de cálculo.</p>","pos":118,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7fcce7","input":"<p>Ahora, la solución mediante descomposición $PA = LU$:</p>","pos":54,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"82fba8","input":"<p>Otra posibilidad para comprobar cómo de próximos están los valores de las matrices  $QR$ y $A$ es hallar la norma matricial de $QR-A$ para ver si está próxima a cero.</p>","pos":15,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"844c11","input":"<h3><strong><a name=\"QR\"></a></strong></h3>\n<h3><strong>Factorización QR de una matriz</strong></h3>\n<p><strong>Teorema</strong></p>\n<p><em>Dada una matriz $A\\in \\mathbb{R}^{m \\times n}$ de rango $n$, existe una matriz  $Q\\in \\mathbb{R}^{m \\times n}$ y otra $R$ no singular de orden $n$, tales que $A=QR$, donde $Q^tQ=I_n\\ $  y $R$ es triangular superior.</em></p>\n<p>La <strong>demostración </strong>consiste en  una interpretación matricial de todo el proceso de ortonormalización de Gram-Schmidt aplicado a las columnas $ a_1,a_2,\\dots,a_n$ de la matriz $A$. A continuación se proporciona la formulación resultante de dicho proceso.</p>\n<p>Si $q_1,q_2,\\dots,q_n$ son las columnas de la matriz buscada $Q$, resultado del proceso de ortonormalización de Gram-Schmidt aplicado sobre las columnas de $A$, tenemos las siguientes fórmulas</p>\n<p>\\begin{align*} \\text{Para cualquier } k\\in\\{1,\\ldots,n\\},\\qquad  y_{k} =& a_{k}-\\sum_{i=1}^{k-1} \\left\\langle q_i,a_{k} \\right\\rangle q_i, \\\\  q_k =& \\frac{1}{\\parallel y_k\\parallel_2}. y_k\\end{align*}</p>\n<p>donde $\\left\\langle a,b \\right\\rangle$ representa el producto escalar usual en $\\mathbb{R}^m$ y $\\parallel a \\parallel_2$ es la norma euclídea asociada.</p>\n<p>Además, sabemos, cada $y_k$ es ortogonal a todos los vectores precedentes $y_1,\\ldots,y_{k-1}$ y, consecuentemente, también es ortogonal a los vectores $a_1,\\ldots,a_{k-1}$; esto es $\\left\\langle y_{k},a_i \\right\\rangle=0$ para cualquier $i \\in \\{1,2,\\dots k-1\\}$.</p>\n<p>Denotemos $R=Q^t A$. Tenemos</p>\n<p>\\begin{align*}R &=Q^t A\\\\[5mm] &=\\left(\\begin{array}{c} q_1^t \\\\ q_2^t\\\\ \\vdots \\\\ q_n^t\\end{array}\\right)\\left( a_1\\ a_2\\ \\dots \\ a_n\\right)\\\\[5mm] & =\\left(\\begin{array}{cccc} q_1^t a_1 & q_1^t a_2 & \\cdots & q_1^t a_n\\\\ q_2^t a_1 & q_2^t a_2 & \\cdots & q_2^t a_n\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ q_n^t a_1 & q_n^t a_2 & \\cdots & q_n^t a_n\\end{array}\\right)\\\\[5mm]&=\\left(\\begin{array}{cccc} \\left\\langle q_1, a_1\\right\\rangle  & \\left\\langle q_1, a_2\\right\\rangle  & \\cdots & \\left\\langle q_1, a_n\\right\\rangle \\\\ \\left\\langle q_2, a_1\\right\\rangle  & \\left\\langle q_2, a_2\\right\\rangle  & \\cdots & \\left\\langle q_2, a_n\\right\\rangle \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\left\\langle q_n, a_1\\right\\rangle  & \\left\\langle q_n, a_2\\right\\rangle  & \\cdots & \\left\\langle q_n,a_n\\right\\rangle \\end{array}\\right)\\\\[5mm]&=\\left(\\begin{array}{cccc} \\left\\langle q_1, a_1\\right\\rangle  & \\left\\langle q_1, a_2\\right\\rangle  & \\cdots & \\left\\langle q_1, a_n\\right\\rangle \\\\ 0 & \\left\\langle q_2, a_2\\right\\rangle  & \\cdots & \\left\\langle q_2, a_n\\right\\rangle \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & \\left\\langle q_n,a_n\\right\\rangle \\end{array}\\right)\\end{align*}</p>\n<p>De dónde $R$  es una matriz triangular superior (es la matriz $R$ buscada) y cada $r_{ii}=\\left\\langle q_i,a_i \\right\\rangle \\neq 0$, por lo que $R$ es también una matriz no singular.</p>\n<p style=\"text-align: center;\"><span style=\"color: #0000ff;\"><br /></span></p>\n<p>La siguiente función proporciona la descomposición $A=QR$, siguiendo el proceso vectorial descrito anteriormente:</p>\n<p style=\"text-align: center;\"><span style=\"color: #0000ff;\">Q, R = factorizacion_QR(A)</span></p>\n<p> </p>\n\n> Ejecutar las dos celdas que siguen para poder utilizar las funciones que definen.","pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"85c480","input":"<p> </p>\n<h3 style=\"font-size: 1.17em; text-align: center;\">ESCUELA DE INGENIERÍA INFORMÁTICA</h3>\n<h3 style=\"font-size: 1.17em; text-align: center;\">UNIVERSIDAD DE SEVILLA</h3>\n<h4 style=\"font-size: 1em; text-align: center;\"><strong>ÁLGEBRA LINEAL Y NUMÉRICA</strong></h4>\n<h3 style=\"font-size: 1.17em;\">Quinta práctica: descomposiciones QR y SVD de una matriz.</h3>\n<p>En esta quinta sesión nos marcamos los siguientes objetivos:</p>\n<p>- Estudiar la <a href=\"#QR\">descomposición QR</a> de una matriz y aportar algoritmos de cálculo.</p>\n<p>- Aplicar la descomposición QR a la <a href=\"#resolucion\">resolución de sistemas lineales</a>, analizando las ventajas.</p>\n<p>- Estudiar la <a href=\"#DVS\">descomposición en valores singulares (SVD)</a> de una matriz y  aportar un algoritmo para su cálculo.</p>\n<p>- <a href=\"#aplicar\">Aplicar  la SVD</a> al problema del cálculo del rango de una matriz y a la compresión de imágenes digitales.</p>\n<p>La práctica finaliza con la realización por parte del alumnado de un <a href=\"#cuestionario\">cuestionario personalizado.</a></p>","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8a48f6","input":"<p>Ahora estudiamos el rango numérico a partir de la descomposición SVD:</p>","pos":90,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"981d44","input":"<p>La solución más próxima a la realidad, pese al mal condicionamiento, se obtiene mediante la descomposición $PLU$, seguida del escalonamiento directo y, finalmente, los peores resultados se obtienen para la factorización QR de la matriz.</p>\n<p>Es una conclusión errónea pensar que este tipo de ejemplos invalida el uso de la descomposición $QR$ como método de resolución de sistemas de ecuaciones. La conclusión es que el método de Gram-Schmidt como procedimiento para obtener una descomposición de tipo $A=QR$ está muy mal condicionado. En un próximo tema veremos técnicas de descomposición $QR$ más sofisticadas y que funcionan bastante mejor para sistemas mal condicionados que las técnicas basadas en escalonamiento; concretamente, estudiaremos factorizaciones  $A=QR$ mediante transformaciones de Householder y mediante rotaciones de Givens.</p>\n\n<h3><span style=\"color: #0000ff;\">Ejemplo 4</span></h3>\n<p><em>Resolver el sistema lineal $Ax=b$ mediante la descomposición $A=QR$, para </em></p>\n<p>$$\\left(\\begin{array}{ccc}1 & 2 & -1\\\\ 3 & 4 & 0\\\\ -1 & 0 & 1\\end{array}\\right),\\ \\ b=\\left(\\begin{array}{c}2\\\\ -1\\\\ 3\\end{array}\\right)$$</p>","pos":61,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9c1870","input":"<p>Obsérvese que los dos últimos valores singulares son muy pequeños, con lo que el rango estimado de la matriz es 10 - 2 = 8. Lo comprobamos con la función rango_SVD:</p>","pos":93,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a08573","input":"<h3><a name=\"aplicar\"></a></h3>\n<h3>Aplicación de la SVD al cálculo del rango de una matriz</h3>\n<p>De la expresión $A=U\\Sigma V^t$ y, puesto que $U$ y $V$ son matrices ortogonales (no singulares) se deduce que </p>\n<p>$$\\operatorname{rango}(A)=\\operatorname{rango}(\\Sigma)=r$$</p>\n<p>siendo $r$ el número de valores singulares no nulos. Podría pensarse que para calcular el rango de una matriz $A$ nada mejor que escalonarla mediante transformaciones elementales y contar el número de pivotes, no obstante, los errores de redondeo y de transmisión durante todo el proceso podrían dar lugar a que filas que sean proporcionales (que se anularían durante el escalonamiento) no lo hagan debido precisamente a esos errores, con lo que el valor final del rango sería erróneo. El siguiente teorema (debido a <a href=\"https://es.wikipedia.org/wiki/Hermann_Weyl\">Hermann Weyl</a>) proporciona una interesante cota.</p>\n<p><strong>Teorema</strong></p>\n<p><em>Sea $A$ una matriz que pretendemos estudiar. Sea $A'$ una aproximación de $A$,  y sean <em>$\\sigma_1 \\geq \\sigma_2 \\geq \\cdots$ los valores singulares de $A'$.</em></em> <em></em></p>\n<p><em>Si $A$ tiene rango $r$, entonces </em></p>\n<p><em>$$\\parallel A-A'\\parallel_2\\ge \\sigma_{r+1}.$$</em></p>\n<p>En conclusión, si el valor de $\\sigma_{r+1}$ es muy elevado, se plantean dos posibilidades:</p>\n<ul>\n<li>o bien el error cometido al aproximar $A$ por $A'$  es grande también,</li>\n<li>o bien el rango de $A$ es mayor que $r$.</li>\n</ul>\n<p>De esta forma podemos elegir como rango de la matriz $A$ el menor $r$ tal que $\\sigma_{r+1}$ (el $(r+1)$-ésimo valor singular de una buena aproximación $A'$) tenga un valor despreciable, muy próximo a cero. Al resultado de determinar el rango de esta forma se le  denomina  <span style=\"color: #ff0000;\"><em>rango numérico</em></span> de la matriz $A$.</p>","pos":79,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"aaf4e2","input":"<p>Primero generamos la solución de  $Ax=b$ tomando como vector solución $x_0=(1,1,\\dots, 1)$ y como vector de términos independientes $b=Ax_0$. De esta forma podemos controlar los errores de cálculo numérico que resulten.</p>","pos":46,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"b60007","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 3</span></h3>\n<p><em>a) Generar una matriz aleatoria $A$ cuadrada de orden 20.</em></p>\n<p><em>b) Comprobar  que el número de condición, para la norma euclídea, en la descomposición $QR=A$ es el mismo para las matrices $A$ y $R$ y que, además, como $Q$ es una matriz ortogonal, tiene $\\kappa_2(Q)=1$.</em></p>\n<p><em>c) Comprobar que para la descomposición $PA=LU$ estudiada en temas anteriores, sucede que $\\kappa(A)$ es bastante menor que $\\kappa(L)\\kappa(U)$.</em></p>\n<p><em>d) Repetir el proceso tomando como A la matriz de Hilbert de orden 20. Comparar las soluciones que se obtiene del sistema cuya solución es el vector $(1,\\ldots ,1)^T$ según los métodos descritos en los apartados b) y c).</em></p>\n<p><em><strong>Observación:</strong> Para los apartados c y d, se redefine aquí la función </em>descompPLU<em> de la Práctica 2 y los procedimientos auxiliares modifica_lado_derecho y sustitucion_regresiva2.</em></p>","pos":34,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c09f10","input":"<p>Compobamos la relación <span style=\"background-color: #ffffff;\"><span style=\"color: #000000;\"> $A=UDV^t$ </span></span> y si las matrices $U$ y $V$ son ortogonales.</p>","pos":72,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c55069","input":"<p>Ahora pasamos tanto la matriz $A$ como el vector $b$ a valores decimales en el anillo RDF:</p>","pos":48,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"cb81ea","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 5</span></h3>\n<p>Hallar la descomposición en valores singulares de la siguiente matriz $A$. </p>","pos":69,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d9e48c","input":"<p>Repetimos para $A_{20}$:</p>","pos":112,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ddac1d","input":"<h3><a name=\"DVS\"></a></h3>\n<h3>Descomposición en valores singulares (SVD) de una matriz</h3>\n<p><strong>Teorema (Descomposición en valores singulares)</strong></p>\n<p>Toda matriz real $A$, de orden $m\\times n$ puede ser factorizada de la forma $A=U\\Sigma V^t$ donde</p>\n<ul>\n<li>$U$ es una matriz ortogonal $m\\times m$,</li>\n<li>$\\Sigma$ es una matriz diagonal $m\\times n$</li>\n<li>$V$ es una matriz ortogonal de orden $n\\times n$.</li>\n</ul>\n<p><strong>Idea constructiva de demostración:</strong></p>\n<p>La matriz $A^tA$ es simétrica de orden $n\\times n$ y semidefinida positiva.</p>\n<p>Resulta, por ello, que sus autovalores son reales no negativos $\\lambda_1 \\ge \\lambda_2 \\ge \\cdots \\ge \\lambda_n$. Las raíces cuadradas de los autovalores, $\\sigma_i = \\sqrt{\\lambda_i}$, son los <strong>valores singulares</strong> de la matriz $A$. Sea $r$ el número de valores singulares no-nulos. Entonces $r$ es el rango de $A$, y tenemos:</p>\n<p>$$\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_r >0, \\quad \\sigma_{r+1}=\\sigma_{r+2}= \\cdots = \\sigma_n=0.$$</p>\n<p> </p>\n<p>Sea $\\{v_1,v_2,\\ldots,v_n\\}$ un conjunto ortonormal de autovectores de $A^tA$, dispuestos de forma que</p>\n<p>$$A^tAv_i=\\sigma_i^2v_i$$</p>\n<p>Se verifica entonces que</p>\n<p>$$\\|Av_i\\|^2_2=v_i^tA^tAv_i=v_i^t\\sigma_i^2v_i=\\sigma_i^2$$</p>\n<p>Construimos la matriz $V$ de orden $n\\times n$ cuyas columnas son $v_1,v_2,\\ldots,v_n$ y definimos</p>\n<p>$$u_i=\\sigma_i^{-1}Av_i\\ \\  1\\leq i\\leq r$$</p>\n<p>Los vectores $u_i$, con $i\\le r$, constituyen un sistema ortonormal.</p>\n<p>Elegimos vectores adicionales $u_{r+1},u_{r+2},\\ldots,u_m$ de tal forma que $\\{u_1,\\ldots,u_m\\}$ constituya una base ortonormal de $\\mathbb{R}^m$ y construimos la matriz $U$ de orden $m\\times m$ cuyas columnas son los vectores $u_i$. Por otra parte,  la matriz $\\Sigma$ de orden $m\\times n$ es una matriz diagonal cuyos elementos diagonales $\\Sigma_{ii}=\\sigma_i\\ $ para $1\\leq i\\leq r$  y los restantes elementos nulos. Finalmente se tiene que</p>\n<p>$$A=U\\Sigma V^t$$</p>\n<p>$$ A=U \\Sigma V^t = (u_1\\ u_2\\dots\\ u_m) \\left(\\begin{array}{cccccc} \\sigma_1 &  &  & & &  \\\\ & \\ddots &  & & &  \\\\  &  &\\sigma_r &  & & \\\\  & & & 0 & &\\\\  & & & & \\ddots & \\\\  & & & & & 0\\end{array}\\right) \\left(\\begin{array}{c}v_1^t\\\\ v_2^t\\\\ \\vdots \\\\ v_n^t\\end{array}\\right)$$</p>\n<p>Una forma especialmente interesante de expresar la descomposición anterior es la siguiente:</p>\n<p>$$A=U\\Sigma V^t=\\sigma_1u_1v_1^t+\\sigma_2u_2v_2^t+\\dots+\\sigma_ru_rv_r^t+0+\\dots+0$$</p>\n<p>que expresa a la matriz $A$, de rango $r$, como suma de $r$ matrices, cada una de ellas de rango 1.</p>\n<div style=\"color: #000000; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; background-position: initial initial; background-repeat: initial initial; margin: 8px;\">\n<p>Podemos calcular la descomposición en valores singulares de una matriz $A$ con la instrucción:</p>\n<p style=\"text-align: center;\"><span style=\"color: #0000ff;\">U, D, V =A.SVD()</span></p>\n<p style=\"text-align: left;\"><span style=\"background-color: #ffffff;\"><span style=\"color: #000000;\">resultando $A=UDV^t$. Es necesario, para usar la instrucción anterior, que la matriz $A$ esté definida en el anillo de números RDF.<br /></span></span></p>\n</div>","pos":68,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e3bef3","input":"<p>Comparamos la norma del error absoluto obtenido por cada método:</p>","pos":58,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ea3e74","input":"<p>También se puede optar por buscar el menor valor $k$ que se estima razonable para tener una buena compresión visual para un nivel de tolerancia dado, <span style=\"color: #0000ff;\">tol</span>, de la aproximación obtenida, en el sentido de que la diferencia $A-A_k$ tenga norma menor que <span style=\"color: #0000ff;\">tol</span>.</p>\n<p>Por ejemplo, tomando <span style=\"color: #0000ff;\">tol</span>=2 en el ejemplo anterior, tendremos:</p>","pos":120,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ee32d1","input":"<p>Obsérvese que las diferencias entre $QR$ y $A$ se deben a pequeños errores de redondeo, del orden de $10^{-16}$ aproximadamente. Existe un método en Sage que, aplicado sobre una matriz $A$, devuelve otra matriz donde se sustituyen  los números próximos a cero por cero, con un nivel de tolerancia determinado, es decir, que si $|a|<tol$ entonces reemplazamos $a=0$. La sintaxis es</p>\n<p><span style=\"font-family: arial,helvetica,sans-serif; color: #0000ff;\">A.zero_at(tol)</span></p>\n<p>donde tol es el nivel de tolerancia.</p>\n<p>Lo aplicamos al resultado anterior, con un nivel de tolerancia tol=$10^{-14}$.</p>","pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f15dec","input":"<div style=\"color: #000000; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; background-position: initial initial; background-repeat: initial initial; margin: 8px;\">\n<p>La siguiente función calcula el<strong style=\"font-weight: bold;\"> rango numérico de una matriz </strong>a partir de su descomposición en valores singulares, con un nivel de tolerancia $\\delta$, dado, esto es  $\\sigma_{r+1}\\leq \\delta$</p>\n<p style=\"text-align: center;\"><span style=\"color: #0000ff;\">rango_SVD(A, tol)</span></p>\n<p style=\"text-align: left;\">el parámetro tol es opcional y su valor por defecto es tol$=10^{-14}$</p>\n</div>","pos":80,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f7ee59","input":"<p>Calculamos la norma de la diferencia entre las matrices que representan las imágenes original y comprimida. Este valor lo llamaremos <strong>nivel de tolerancia de la aproximación</strong> (realmente es el error absoluto entre ambas matrices). Obviamente, mientras más próximo a cero sea el nivel de tolerancia, mayor será la similitud entre ambas imágenes.</p>","pos":110,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f7f03e","input":"<p>Podemos visualizar la imagen mediante la siguiente instrucción:</p>","pos":98,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f84692","input":"<p>Visualizamos la lista de valores singulares de la matriz $A$, ordenados de mayor a menor:</p>","pos":102,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"fa9f9c","input":"<h3><span style=\"color: #0000ff;\">Ejemplo 1</span></h3>\n<p>Vamos a hallar la factorización $QR$ de una matriz $A$ de orden $4 \\times 3$:</p>","pos":4,"state":"done","type":"cell"}
{"id":0,"time":1619849704037,"type":"user"}
{"last_load":1619849708271,"type":"file"}